;; tell Eclipse, etc. to read the templates from the wmeTypes.clp file
(require* wmeTypes "wmeTypes.clp")

(defglobal ?*debug* = FALSE)
(defglobal ?*trace* = FALSE)

;; Issues
;; - 4x-3=9  looks like cur-transformation and cur-equation are not updated after second transformation is complete?

;; Started to implement the strict condition but then wondered whether that is a good next step.
;; Other possible to do's:
;; Generalize to more problem types.  E.g., c = ax + b, ax + b = cx + d
;; Generalize to even more problem types.
;; Make the model useful for tutoring
;;   - define conditions of rules better?
;;   - deal with the intermediate steps (what is the desired tutor behavior?)
;;   - does having rules for the strict standard condition for logging really work?

;; More to do items
;; - figure out a general solution for fact numbering (or is it possible in a newer Jess to have 
;;    multiple copies of facts with the same slot values?)
;; - generalize across quotient and product terms?
;; - change name of factors slot in quotient term template?
;; - split move-simple-term-left-to-right into rules for constant term and var term?
;; - avoid creating simple terms with coefficient 0?  (see condition of move rule)
;; - now prints 2*(x + 4) + 3x - 3 = 0, make it print this as 2(x + 4) + 3x - 3 = 0
;; - test move-simple-term-left-to-right when there is more than just a constant on the right
;; - make sure cannot divide by 0?
;; - deal with other cases that involve 0?

;; Ideas
;; - for efficiency, create a layered model? where more general versions of a strategy are matched
;;      first, followed by more specific versions (and all are written in the logs, to help analysis)
;; - generalize move rules so they work l->r and r->l
;; - same for other rules?
;; - implement general rules first? that define the space of allowable solutions, though may not be good for hints
;;   - add constant to both sides
;;   - add var term to both sides
;;   - same for subtract?
;;   - add complex term to both sides?
;;   - combine like terms (could the existing rule work?)
;;   - divide (could the existing rule work?)
;;   - distribute (could the existing rule work?)
;;   
;; 


;;----------------------------------------------------------------------------------------
;;
;; Functions for printing out expressions and equations - for hints, development, etc.
;;

(deffunction term->string (?term ?parentheses-p ?op-minus-p ?op-p)    ; perhaps this should not be re-computed each time?
       ; ?parentheses-p:  wrap terms with negative coefficients in parentheses  (probably should test that ?op-minus = FALSE ??)
       ; ?op-minus-p:  whether terms with negative coeff are written as  ... + -7 ... (?op-minus-p = FALSE)   or ... - 7 ...  (?op-minus-p = TRUE)
       ; ?op-p:  include op or not, i.e., whether you get " + 7x" or "7x" - should maybe be separated out
       ; these controls interact to some degree:
       ;  - don't want parentheses when there is no op?  maybe that is OK (so will get parentheses for now)
       ;  - cannot drop negative coefficient for first term, so when ?op-p equals TRUE, need to keep the negative coeff 

    	(if (= TRUE ?*debug*) then            
	    (printout t "term->string: ?term = " ?term ", ?parentheses-p = " ?parentheses-p ", ?op-minus-p = " ?op-minus-p ", ?op-p = " ?op-p crlf )
    )
       ; could test for jess-type is fact, but not for specific type of fact? how bizarre
  	  (bind ?type (fact-slot-value ?term type))
      (if (=  simple-term ?type)     ; is there a way to match a given fact against a pattern?
        then
        (bind ?coeff (fact-slot-value ?term coeff))
        (bind ?var (fact-slot-value ?term var))
        (bind ?op (if (and (= TRUE ?op-minus-p)(< ?coeff 0)) then " - " else " + "))
        (bind ?op (if (= TRUE ?op-p) then ?op else ""))
        (bind ?par1 (if (and (= ?parentheses-p TRUE)(< ?coeff 0)) then "(" else ""))
        (bind ?par2 (if (and (= ?parentheses-p TRUE)(< ?coeff 0)) then ")" else ""))
        (bind ?coeff (if (and (= TRUE ?op-minus-p)(= ?op-p TRUE)(< ?coeff 0)) then (* -1 ?coeff) else ?coeff))
        (bind ?return-value
                (str-cat ?op
                			?par1
                			(if (and (= 1 ?coeff)(not (= nil ?var))) then "" else ?coeff)
                			(if (= nil ?var) then "" else ?var)
                			?par2))
    				(if (= TRUE ?*debug*) then            
                		(printout t "term->string ?return-value = " ?return-value crlf crlf))
        			(return ?return-value)
        else (if (or (= quotient-term ?type)(= product-term ?type))
        then
        (bind ?factors (fact-slot-value ?term factors))
        (bind ?f1 (nth$ 1 ?factors))     ; would it be better to make this a recursive call to terms-insert-op$ ?
        (bind ?f2 (nth$ 2 ?factors))
               ; should a factor in a quotient/product term that is not a simple term
               ;   (i.e., an expression with multiple terms)
               ;   always be in parentheses?  probably, answer is yes
        (bind ?terms1 (fact-slot-value ?f1 terms))  ; ?f1 and ?f2 are expr so accessing the terms slot is safe
        (bind ?terms2 (fact-slot-value ?f2 terms))
        (bind ?par1a (if (> (length$ ?terms1) 1) then "(" else ""))
        (bind ?par1b (if (> (length$ ?terms1) 1) then ")" else ""))
        (bind ?par2a (if (> (length$ ?terms2) 1) then "(" else ""))
        (bind ?par2b (if (> (length$ ?terms2) 1) then ")" else ""))
                        
        (bind ?op (if (= TRUE ?op-p) then " + " else ""))
        (bind ?return-value
        	      (str-cat ?op
                       ?par1a
                    	   (expr->str1 ?f1)
                       ?par1b
            			   (if (= quotient-term ?type) then "/" else "*")
                       ?par2a
                	       (expr->str1 ?f2)
                    	   ?par2b
                    	))
    		(if (= TRUE ?*debug*) then            
        		(printout t "term->string ?return-value = " ?return-value crlf crlf))
        (return ?return-value)
        else 
        (return "<< Not a simple term, quotient term, or product term >>")
    )))

(deffunction terms-insert-op$ (?list ?parentheses-p ?op-minus-p)   ; 
    	(if (= TRUE ?*debug*) then            
        (printout t "terms-insert-op$, ?list = " ?list ", ?parentheses-p = " ?parentheses-p ", ?op-minus-p = " ?op-minus-p crlf))
    (if (> (length$ ?list) 0)    ; should be easier test whether a list is empty in Jess??
        then
        (bind ?return-value
        		  (str-cat (term->string (nth$ 1 ?list) ?parentheses-p ?op-minus-p TRUE)
                		   (terms-insert-op$ (rest$ ?list) ?parentheses-p ?op-minus-p)))
    		(if (= TRUE ?*debug*) then            
            (printout t "terms-insert-op$ ?return-value = " ?return-value crlf crlf))
        (return ?return-value)
        else
        (return "")  ; empty list
    ))

(deffunction expr->str1 (?expr)   ; insert + in between terms, return string
    	(if (= TRUE ?*debug*) then            
        (printout t "expr->str1" ?expr crlf))
    (bind $?terms (fact-slot-value ?expr terms))
    (bind ?tmp (terms-insert-op$ (rest$ $?terms) FALSE FALSE))
    (return (str-cat (term->string (nth$ 1 $?terms) FALSE FALSE FALSE) ?tmp))
                ; is the call to return necessary??
    )

(deffunction expr->str2 (?expr)   ; insert + in between terms, with negative terms in parentheses, return string
    (bind $?terms (fact-slot-value ?expr terms))
    (bind ?tmp (terms-insert-op$ (rest$ $?terms) TRUE FALSE))
    (return (str-cat (term->string (nth$ 1 $?terms) TRUE FALSE FALSE) ?tmp))
                ; is the call to return necessary??
    )

(deffunction expr->str3 (?expr)   ; insert + or - in between terms, return string
    (bind $?terms (fact-slot-value ?expr terms))
    (bind ?tmp (terms-insert-op$ (rest$ $?terms) FALSE TRUE))
    (bind ?result (str-cat (term->string (nth$ 1 $?terms) FALSE TRUE FALSE) ?tmp))   
;    (printout t crlf "expr->str3(" ?expr ") = " ?result crlf)
    (return ?result)
                ; is the call to return necessary??
    )

(deffunction copy-term (?term)     ; Jess should provide this kind of function
  	(bind ?type (fact-slot-value ?term type))
    (if (=  simple-term ?type)
        then
        (bind ?c (fact-slot-value ?term coeff))
        (bind ?v (fact-slot-value ?term var))
        (return (assert (simple-term (coeff ?c)(var ?v))))  ; type and fact-nr slots filled in by default
    else (if (= product-term ?type)
        then
        (bind ?factors (map copy-expr (fact-slot-value ?term factors)))
        (return (assert (product-term (factors ?factors))))
    else (= quotient-term ?type)
        then
        (bind ?factors (map copy-expr (fact-slot-value ?term factors)))
        (return (assert (quotient-term (factors ?factors))))
                else   ; something is wrong
        (return FALSE)
    )))

(deffunction copy-expr (?expr)
    ; slots are terms, type, and fact-nr
    (bind $?new-terms (map copy-term (fact-slot-value ?expr terms)))
    (return (assert (expr (terms $?new-terms))))  ; type and fact-nr slots filled in by default
    )

(deffunction copy-transf (?transf)
    (bind ?new-transf
        	(assert (transformation       ; don't want to use duplicate because I want a new fact number (so the fact is unique)
                	  (equation (copy-eq (fact-slot-value ?transf equation)))      
                  (to-be-simplified (fact-slot-value ?transf to-be-simplified))
    				  (written (fact-slot-value ?transf written))
    				  (focus (fact-slot-value ?transf focus))
    	 			  (prev-left-val (fact-slot-value ?transf prev-left-val))
                  (prev-right-val (fact-slot-value ?transf prev-right-val))
                  (description (fact-slot-value ?transf description))
                  (pre-explained (fact-slot-value ?transf pre-explained))
                  (post-explained (fact-slot-value ?transf post-explained))
                  (skip-expl-sel2 (fact-slot-value ?transf skip-expl-sel2))
                )))
    (return ?new-transf)
    )

(deffunction copy-eq (?eq)      ; no type checking?
    (return
     (assert
      (equation
       (sides
        (create$
         (copy-expr (nth$ 1 (fact-slot-value ?eq sides)))
         (copy-expr (nth$ 2 (fact-slot-value ?eq sides)))))))))

(deffunction print-eq (?eq)
    (bind ?sides (fact-slot-value ?eq sides))
    (bind ?left (nth$ 1 ?sides))
    (bind ?right (nth$ 2 ?sides))
    (printout t (expr->str1 ?left) " = " (expr->str1 ?right) crlf)
    (printout t (expr->str2 ?left) " = " (expr->str2 ?right) crlf)
    (printout t (expr->str3 ?left) " = " (expr->str3 ?right) crlf)
    )

(deffunction simple-terms-only-p$ (?terms)
   (if (= 0 (length$ ?terms)) then
        (return TRUE)
   else 
   (bind ?first (nth$ 1 ?terms))
   (if (eq simple-term (fact-slot-value ?first type)) then
        (return (simple-terms-only-p$ (rest$ ?terms)))
   else
   (return FALSE)
    )))

(deffunction remove-whitespace (?s)
   (bind ?result "")
   (for (bind ?i 1) (<= ?i (str-length ?s)) (++ ?i)
        (bind ?c (sub-string ?i ?i ?s))
        (if (neq ?c " ") then (bind ?result (str-cat ?result ?c))))
   (return ?result)
         )

;;----------------------------------------------------------------------------------------
;;
;; Some functions used in calls to predict
;;

(defglobal ?*add-or-subtract-list* = (create$ "Add" "Added" "Subtract" "Subtracted"))

(deffunction add-or-subtract-p (?model ?student)
    ; can ignore ?model
;   (printout t crlf crlf "add-or-subtract-p, ?model = " ?model ", student = " ?student)
	(bind ?result (member$ ?student ?*add-or-subtract-list*))  
;   (printout t crlf "?result = " ?result crlf crlf)
    (return (if (numberp ?result) then TRUE else (if (eq FALSE ?result) then FALSE else FALSE)))
         ; weird, I know
        )

(deffunction num-equal-p (?model ?student)   ; could use "="  in call to predict but then we
              ; get an error when the two things are not numbers
;    (printout t crlf "num-equal-p ?model = " ?model ", ?student = " ?student crlf)
;    (printout t crlf "(numberp ?model) = " (numberp ?model) crlf)
;    (printout t crlf "(numberp ?student) = " (numberp ?student) crlf)
    (or (eq ?model ?student)     ; this is crazy
        (and (stringp ?model)
             (stringp ?student)
             (algEquivTerms ?model ?student)    ; maybe should have used this in the first place ...
            )
        (and (numberp ?model)
             (numberp ?student)
             (= ?model ?student)))
    )

(deffunction sides-equal-p (?model ?student)
    (printout t crlf "sides-equal-p, ?model = " ?model ", ?student = " ?student crlf)
    (printout t crlf "sides-equal-p, (stringp ?model) = " (stringp ?model)
                                     ", (stringp ?student) = " (stringp ?student) crlf)
    (printout t crlf "sides-equal-p, (symbolp ?model) = " (symbolp ?model)
                                     ", (symbolp ?student) = " (symbolp ?student) crlf)
        
    (or (and (eq ?model "left")
            (eq ?student "to the left side"))
        (and (eq ?model "right")
            (eq ?sudent "to the right side"))
        ))


;;----------------------------------------------------------------------------------------
;;
;; Some keyboard functions for development
;;

(deffunction prpreq (?prob-fact-id)     ; print the current equation in the problem fact
                                      ;   could probably figure out id automatically, but this is fine for now
    (print-eq (fact-slot-value (fact-id ?prob-fact-id) cur-equation))
    )

(deffunction preq (?eq-fact-id)
    (print-eq  (fact-id ?eq-fact-id) )
    )

;;----------------------------------------------------------------------------------------
;;
;; Rules
;;

;; Anatomy of a chain
;;
;; 1. record-pre-state; needed so that successful steps can be undone
;; 2. when there is no transformation, a rule that creates one (i.e., a transformation rule)
;; 3. a focus rule (sets the focus to left or right) or an explanation rule
;;    (focus rules appear to be necessary so that in the chain that writes the left side no simplifications
;;    of the right side are done, and vice versa ... )
;;    TO DO: should we have a rule that sets the focus to explanation? might trim the conflict tree on solving
;;        steps - also, would mean we do not need to worry about simplication rules inadvertently showing
;;        up in the chains for the explanation steps (although since the explanation rules don't change the
;;        transformation fact that would not create erroneous)
;; 4. when the focus is left or right, zero or more simplification rules followed by a write rule (could be
;;    write-intermediate or write; the latter removes the transformation)
;; TO DO:  transformation cannot be removed until the explanation has been written
;; TO DO:  the write rules do a lot of stuff on their rhs (and there will be more still); any chance that
;;         that they could be refactored so that work can be done in a single rule?
;; TO DO:  do we really need separate write-left and write-right rules? same for the write-intermediate rules?
;;
;; Quick high level gloss of the model: the main operations/transformation are modeled as rules that create
;;    a transformation fact, whereas the rules that take care of the simplifications respond to these
;;    facts ... (but do not create a transformation fact).
;;

;;-----------------------------------------------------------------------------------------------------------
;;
;; Transformation rules - Standard Strategy
;;
;;
;; These rules capture the main operations but not the details of wether intermediate steps are written out, etc.
;; They all have in common that they create a transformation fact and that they can only fire when there is no such
;;     fact.
;;
;; Nan Li in her EDM talk said that student performance goes down when the variable is on the right. So we should have
;;   separate rules.
;; Also need separate rules for when variable coefficient is 1 or -1.
;; Separate for positive and negative more generally?
;; 

;; Standard strategy (see Waalkens et al., 2013)
;; 1. use the distributive law to expand any term in parentheses
;; 2. combine constant terms and variable terms on each side of the equation
;; 3. move variable terms to one side of the equation and constant terms to the other side
;; 4. divide both sides by the coefficient of the variable term.

;; IDEA:  Use "edit distance" between input strings to prune the search?



; MOVE Rules that conform to standard strategy ... come after multiplying through and combining like terms
;
; Analysis of when a move is allowed under the standard strategy
; Steps 1 and 2 must be done, so no complex terms on either side and no like terms on any given side
; So can have 0, 1, or 2 terms on either side; however, moving makes sense only if the side being moved
; from has 2 terms
;
; C = constant term
; V = variable term
;
; Side to move from - Possible move term - Side to move to - Strategic?
; CV                    C                   0                  Yes
; CV                    C                   C                  Yes
; CV                    C                   V                  No  (CV = C --> V = CV means no progress)
; CV                    C                   CV                 Yes (CV = CV --> V = CV after cleanup)
; CV                    V                   0                  Yes
; CV                    V                   C                  No  (CV = C --> C = CV means no progress)
; CV                    V                   V                  Yes
; CV                    V                   CV                 Yes (CV = CV --> V = CV after cleanup)

; Conditions:
; Sides have only simple terms (or one side could be 0)
; Each side only has unlike terms

; So:
; Side from which to move has exactly 2 simple terms that are unlike terms
; The move term is one of these terms (obviously)
; The other side has only simple terms that are unlike terms (meaning 0, 1, or 2 terms)
; The other side is not a single term that is unlike the one being moved - in other words, the either side
;     is either 0 or has a simple term that is like the one being moved (and no other )


; TO DO: split into rules for moving constant and moving var?
; TO DO: split into rules for moving terms with negative and positive coefficients?
; TO DO: split into rules for terms with coefficient = 1 or -1?
; would fit with the strategy of making a maximally granular model and would not explode the
; conflict tree because the total number of rule activations would not
; change (i.e., one for each moveable term)
    
(defrule move-simple-term-to-right
    (declare (salience 1000))    ; so it is used before the more flexible rules
        ; moves a simple term from left to right,
        ; but only if there is a like term on the right (i.e., like the term being moved),
        ;    (note: this criterion is too strong if you consider -3x+3=0; moving -3x is
        ;    helpful, even though there is no like term on the right; right side that is 0 covered by separate rule)
        ; and only if there are two simple, unlike terms on the left
        ;    (note: minimum criterion for the move being minimally strategic is that there
        ;     is more than one term on the left; but standard strategy requires stronger condition)
        ;     --> or does it?  check C&E article ...
        ; and only if there are at most two simple, unlike terms on the right
        ; (so this captures the standard strategy - getting rid of parentheses, combining like terms has been done)
        ; with intermediate step (i.e., no canceling on the left, combining like terms on the right)
        ;
    ?prob <- (problem (cur-equation ?eq)(cur-transformation nil)
        				  (cur-step ~nil))     ; so that record-pre-state goes first
    ?eq <- (equation (sides ?left ?right))
    ?left <- (expr (terms ? ?))  ; total of two terms
    ?left <- (expr (terms $?before ?move-term $?after))
    ?left <- (expr (terms $? ?other-term $?))
    (test (neq ?move-term ?other-term))
    ?move-term <- (simple-term (coeff ?coeff&~0)(var ?var))  ; no condition that ?var is non-nil
                                                ; (rule covers moving constant term or variable term)
    ?other-term <- (simple-term (var ~?var))   ; other term is an unlike term    
      ; now check the right has either one term (i.e., the one that is like the term being moved)
      ;    or has two simple terms, one that is like the one being moved, the other a simple term
      ;         and unlike term
    ?right <- (expr (terms $?right-terms))
    ?right <- (expr (terms $? ?like-term $?))
    ?like-term <- (simple-term (var ?var)(coeff ~0))    ; exclude zero
    ?right <- (expr (terms $? ?possible-unlike-term $?))
           ; note: there may not be a match with ?possible-unlike-term bound to a different term
           ;     (i.e., different from ?like-term)
           ; but there is always a match with ?possible-unlike-term = ?like-term so this pattern never fails
    ?possible-unlike-term <- (simple-term (var ?var2))
    (test (or (= 1 (length$ $?right-terms))
            	  (and (= 2 (length$ $?right-terms))
                	   (neq ?var ?var2)  ; ensure that ?possible-unlike-term is indeed an unlike term
                )))
=>
    (bind ?new-coeff (* -1 ?coeff))
    (bind ?new-term (assert (simple-term (coeff ?new-coeff)(var ?var))))
    (bind ?new-term-string (term->string ?new-term FALSE  FALSE FALSE))
    	(bind ?new-left (assert (expr (terms $?before ?move-term ?new-term $?after))))
               ; inserts the new term immediately following the term being moved
    (bind ?new-right (assert (expr (terms $?right-terms ?new-term))))
               ; inserts the new term at the end (not that it matters much)
    (bind ?new-eq (assert (equation (sides ?new-left ?new-right))))
    (bind ?transf (assert (transformation (equation ?new-eq)(to-be-simplified left right)
                			  (description add ?new-term both)  
                ; add ?new-term to both sides - used for explanation
                ; assume it is a term but not always a simple term (though this rule only deals with moving
                ;    simple terms, obviously)
                ; TO DO:  or generalize this even further, to moving entire expressions? maybe not ...
                				)))
    (modify ?prob (cur-transformation ?transf))
    
    (if (= TRUE ?*trace*) then
	    (printout t "Move " (term->string ?move-term FALSE FALSE FALSE) " to the right" crlf)
    		(print-eq ?new-eq)
    		(printout t crlf))
        )

(defrule move-simple-term-to-left   ; analogous to move-simple-term-to-right   
    (declare (salience 1000))    ; so it is used before the more flexible rules
    ?prob <- (problem (cur-equation ?eq)(cur-transformation nil)
        				  (cur-step ~nil))     ; so that record-pre-state goes first
    ?eq <- (equation (sides ?left ?right))
    ?right <- (expr (terms ? ?))  ; total of two terms
    ?right <- (expr (terms $?before ?move-term $?after))
    ?right <- (expr (terms $? ?other-term $?))
    (test (neq ?move-term ?other-term))
    ?move-term <- (simple-term (coeff ?coeff&~0)(var ?var))  
    ?other-term <- (simple-term (var ~?var)) 
    ?left <- (expr (terms $?left-terms))
    ?left <- (expr (terms $? ?like-term $?))
    ?like-term <- (simple-term (var ?var)(coeff ~0))    ; exclude zero
    ?left <- (expr (terms $? ?possible-unlike-term $?))
           ; note: there may not be a match with ?possible-unlike-term bound to a different term
           ;     (i.e., different from ?like-term)
           ; but there is always a match with ?possible-unlike-term = ?like-term so this pattern never fails
    ?possible-unlike-term <- (simple-term (var ?var2))
    (test (or (= 1 (length$ $?left-terms))
            	  (and (= 2 (length$ $?left-terms))
                	   (neq ?var ?var2)  ; ensure that ?possible-unlike-term is indeed an unlike term
                )))
=>
    (bind ?new-coeff (* -1 ?coeff))
    (bind ?new-term (assert (simple-term (coeff ?new-coeff)(var ?var))))
    	(bind ?new-right (assert (expr (terms $?before ?move-term ?new-term $?after))))
               ; inserts the new term immediately following the term being moved
    (bind ?new-left (assert (expr (terms $?left-terms ?new-term))))
               ; inserts the new term at the end (not that it matters much)
    (bind ?new-eq (assert (equation (sides ?new-left ?new-right))))
    (bind ?transf (assert (transformation (equation ?new-eq)(to-be-simplified left right)
                			  (description add ?new-term both)    
                ; add ?new-term to both sides - used for explanation
                				)))
    (modify ?prob (cur-transformation ?transf))
    
    (if (= TRUE ?*trace*) then
	    (printout t "Move " (term->string ?move-term FALSE FALSE FALSE) " to the left" crlf)
    		(print-eq ?new-eq)
    		(printout t crlf))
        )

; when are transformations consistent?  is having the same operator the only requirement?
; this rule is needed when dealing with pre-explanations, 
(defrule same-op-as-prov-transformation
   ?prob <- (problem (cur-transformation ?cur)(prov-transformation ?prov))
   ?cur <- (transformation (description ?op ? ?))
   ?prov <- (transformation (description ?op ? ?))
  =>
   (modify ?prob (prov-transformation nil))     
    )

; TO DO: bump up salience to 1000 (but low salience good for testing move-simple-term)
(defrule move-simple-term-to-zero-right   ; when there is a 0 only on one side, makes sense to move
           ; either constant or var term
           ; TO DO: or select the move so you end up with var term with positive coeff?
    (declare (salience 1000))
    ?prob <- (problem (cur-equation ?eq)(cur-transformation nil)(cur-step ~nil))
    ?eq <- (equation (sides ?left ?right))
    ?left <- (expr (terms ? ?))  ; total of two terms
    ?left <- (expr (terms $?before ?move-term $?after))
    ?left <- (expr (terms $? ?other-term $?))
    (test (neq ?move-term ?other-term))
    ?move-term <- (simple-term (coeff ?coeff&~0)(var ?var))  ; no condition that ?var is non-nil
                                                ; (rule covers moving constant term or variable term)
    ?other-term <- (simple-term (var ~?var))   ; other term is an unlike term    
      ; now check the right has a 0 terms only
    ?right <- (expr (terms ?right-term))  ; only a single 
    ?right-term <- (simple-term (coeff 0))    ; coefficient is zero
=>
    (bind ?new-coeff (* -1 ?coeff))
    (bind ?new-term (assert (simple-term (coeff ?new-coeff)(var ?var))))
    	(bind ?new-left (assert (expr (terms $?before ?move-term ?new-term $?after))))
               ; inserts the new term immediately following the term being moved
    (bind ?new-right (assert (expr (terms ?right-term ?new-term))))  ; so student can write 0-5 or 0-5x
               ; inserts the new term at the end (not that it matters much)
    (bind ?new-eq (assert (equation (sides ?new-left ?new-right))))
    (bind ?transf (assert (transformation (equation ?new-eq)(to-be-simplified left right)
                				(description add ?new-term both))))
    (modify ?prob (cur-transformation ?transf))
    
    (if (= TRUE ?*trace*) then
	    (printout t "Move " (term->string ?move-term FALSE FALSE FALSE) " to the right" crlf)
    		(print-eq ?new-eq)
    		(printout t crlf))
    )

; TO DO: bump up salience to 1000 (but low salience good for testing move-simple-term)
(defrule move-simple-term-to-zero-left   ; when there is a 0 only on one side, makes sense to move
           ; either constant or var term - or select the move so you end up with var term with positive coeff?
	(declare (salience 1000))
    ?prob <- (problem (cur-equation ?eq)(cur-transformation nil)(cur-step ~nil))
    ?eq <- (equation (sides ?left ?right))
    ?right <- (expr (terms ? ?))  ; total of two terms
    ?right <- (expr (terms $?before ?move-term $?after))
    ?right <- (expr (terms $? ?other-term $?))
    (test (neq ?move-term ?other-term))
    ?move-term <- (simple-term (coeff ?coeff&~0)(var ?var))  ; no condition that ?var is non-nil
                                                ; (rule covers moving constant term or variable term)
    ?other-term <- (simple-term (var ~?var))   ; other term is an unlike term    
      ; now check the left is a zero term
    ?left <- (expr (terms ?left-term))  ; only a single 
    ?left-term <- (simple-term (coeff 0))    ; coefficient is zero
=>
    (bind ?new-coeff (* -1 ?coeff))
    (bind ?new-term (assert (simple-term (coeff ?new-coeff)(var ?var))))
    	(bind ?new-right (assert (expr (terms $?before ?move-term ?new-term $?after))))
               ; inserts the new term immediately following the term being moved
    (bind ?new-left (assert (expr (terms ?left-term ?new-term))))  ; so student can write 0-5 or 0-5x
               ; inserts the new term at the end (not that it matters much)
    (bind ?new-eq (assert (equation (sides ?new-left ?new-right))))
    (bind ?transf (assert (transformation (equation ?new-eq)(to-be-simplified left right)
                				(description add ?new-term both))))
    (modify ?prob (cur-transformation ?transf))
    
    (if (= TRUE ?*trace*) then
	    (printout t "Move " (term->string ?move-term FALSE FALSE FALSE) " to the left" crlf)
    		(print-eq ?new-eq)
    		(printout t crlf))
    )


; conforms to standard strategy:  only when terms in parentheses have been eliminated
; TO DO:  have a rule for combining like terms on both sides?
; TO DO:  capture the common parts of the two combine rules in a single rule (or rules)?
(defrule combine-like-terms-left   ; should we have separate rules for combining constants and combining variables? 
             ; this rule works for constant terms and variable terms
             ; would it be better to have one cancel rule that works for both sides?  or start with a maximally granular model?
    ?prob <- (problem (cur-equation ?eq)(cur-transformation nil)(cur-step ~nil))
    ?eq <- (equation (sides ?left ?right))    ; probably won't work in the long run ...
    ?left <- (expr (terms $?left-terms))
    ?right <- (expr (terms $?right-terms))
    (test (simple-terms-only-p$ $?left-terms))
    (test (simple-terms-only-p$ $?right-terms))    ; to strictly enforce the standard strategy
    ?left <- (expr (terms $?before ?t1 $?between ?t2 $?after))
    ?t1 <- (simple-term (coeff ?c1)(var ?var))
    ?t2 <- (simple-term (coeff ?c2)(var ?var))
=>
    	(bind ?new-term (assert (simple-term (coeff (+ ?c1 ?c2))(var ?var))))
    (bind ?new-left (assert (expr (terms $?before ?new-term $?between $?after))))
    (bind ?new-eq (assert (equation (sides ?new-left ?right))))     ; this step would be more difficult in a rule that works on both sides ...
    (bind ?transf (assert (transformation (equation ?new-eq)
                            (description combine 0 left)(skip-expl-sel2 TRUE))))    ; 0 just a place holder
             ; no intermediate step for combine like terms?
    (modify ?prob (cur-transformation ?transf))
 
    (if (= TRUE ?*trace*) then
        (printout t "Combine like terms " (term->string ?t1 FALSE FALSE FALSE)
            " and " (term->string ?t2 FALSE FALSE FALSE)" on the left" crlf)
    		(print-eq ?new-eq)
    		(printout t crlf))
    )  

(defrule combine-like-terms-right   
             ; TO DO: should we have separate rules for combining constants and combining variables? 
             ; this rule works for constant terms and variable terms
             ; would it be better to have one cancel rule that works for both sides?  or start with a maximally granular model?
    ?prob <- (problem (cur-equation ?eq)(cur-transformation nil)(cur-step ~nil))
    ?eq <- (equation (sides ?left ?right))    ; probably won't work in the long run ...
    ?left <- (expr (terms $?left-terms))
    ?right <- (expr (terms $?right-terms))
    (test (simple-terms-only-p$ $?left-terms))
    (test (simple-terms-only-p$ $?right-terms))    ; to strictly enforce the standard strategy
    ?right <- (expr (terms $?before ?t1 $?between ?t2 $?after))
    ?t1 <- (simple-term (coeff ?c1)(var ?var))
    ?t2 <- (simple-term (coeff ?c2)(var ?var))
=>
    	(bind ?new-term (assert (simple-term (coeff (+ ?c1 ?c2))(var ?var))))
    (bind ?new-right (assert (expr (terms $?before ?new-term $?between $?after))))
    (bind ?new-eq (assert (equation (sides ?left ?new-right))))     ; this step would be more difficult in a rule that works on both sides ...
    (bind ?transf (assert (transformation (equation ?new-eq)
                           (description combine 0 right)(skip-expl-sel2 TRUE))))    ; 0 just a place holder
             ; no intermediate step for combine like terms?
    (modify ?prob (cur-transformation ?transf))
 
    (if (= TRUE ?*trace*) then
        (printout t "Combine like terms " (term->string ?t1 FALSE FALSE FALSE)
            " and " (term->string ?t2 FALSE FALSE FALSE)" on the right" crlf)
    		(print-eq ?new-eq)
    		(printout t crlf))
    )  


; in standard strategy, division comes last ... only a var term left on the left and a constant term on the right
(defrule divide-both-sides-by-left-var-coeff     ; what are the conditions?  only when one term left?
    ?prob <- (problem (cur-equation ?eq)(cur-transformation nil)(cur-step ~nil))
    ?eq <- (equation (sides ?left ?right))
    ?left <- (expr (terms ?t1))  ; only one term
    ?t1 <- (simple-term (coeff ?c1&~1)(var ?var&~nil))  ; divide only by the coefficient of the variable term
    ?right <- (expr (terms ?t2))
    ?t2 <- (simple-term (var nil))
=>
    	(bind ?divisor-term (assert (simple-term (coeff ?c1))))
    (bind ?divisor-expr (assert (expr (terms ?divisor-term))))
    (bind ?new-term-left (assert (quotient-term (factors ?left ?divisor-expr))))
    (bind ?new-left (assert (expr (terms ?new-term-left))))
    (bind ?new-term-right (assert (quotient-term (factors ?right ?divisor-expr))))
    (bind ?new-right (assert (expr (terms ?new-term-right))))
    (bind ?new-eq (assert (equation (sides ?new-left ?new-right))))
    (bind ?transf (assert (transformation (equation ?new-eq)(to-be-simplified left right)
                                          (description divide ?divisor-term both))))
    (modify ?prob (cur-transformation ?transf))
 
    (if (= TRUE ?*trace*) then
        (printout t "Divide both sides by " (term->string ?divisor-term FALSE FALSE FALSE) crlf)
    		(print-eq ?new-eq)
    		(printout t crlf))
    )

(defrule divide-both-sides-by-right-var-coeff     ; what are the conditions?  only when one term left?
    ?prob <- (problem (cur-equation ?eq)(cur-transformation nil)(cur-step ~nil))
    ?eq <- (equation (sides ?left ?right))
    ?right <- (expr (terms ?t1))  ; only one term
    ?t1 <- (simple-term (coeff ?c1&~1)(var ?var&~nil))  ; divide only by the coefficient of the variable term
    ?left <- (expr (terms ?t2))
    ?t2 <- (simple-term (var nil))
=>
    	(bind ?divisor-term (assert (simple-term (coeff ?c1))))
    (bind ?divisor-expr (assert (expr (terms ?divisor-term))))
    (bind ?new-term-right (assert (quotient-term (factors ?right ?divisor-expr))))
    (bind ?new-right (assert (expr (terms ?new-term-right))))
    (bind ?new-term-left (assert (quotient-term (factors ?left ?divisor-expr))))
    (bind ?new-left (assert (expr (terms ?new-term-left))))
    (bind ?new-eq (assert (equation (sides ?new-left ?new-right))))
    (bind ?transf (assert (transformation (equation ?new-eq)(to-be-simplified left right)
                                          (description divide ?divisor-term both))))
    (modify ?prob (cur-transformation ?transf))
 
    (if (= TRUE ?*trace*) then
        (printout t "Divide both sides by " (term->string ?divisor-term FALSE FALSE FALSE) crlf)
    		(print-eq ?new-eq)
    		(printout t crlf))
    )

;; TO DO:  do we need to model distributing on both sides at once?
(defrule distribute-left
    ?prob <- (problem (cur-equation ?eq)(cur-transformation nil)(cur-step ~nil))
    ?eq <- (equation (sides ?left ?right))
    ?left <- (expr (terms $?before ?left-product $?after))
    ?left-product <- (product-term (factors $? ?a-expr $?))
    ?left-product <- (product-term (factors $? ?bx+c-expr $?))
    (test (not (eq ?a-expr ?bx+c-expr)))
    ?a-expr <- (expr (terms ?a-term))
    ?a-term <- (simple-term (coeff ?a)(var nil))  ; does it matter that for some probs there is a var of the same name in the wme file?
    ?bx+c-expr <- (expr (terms $? ?bx-term $?))
    ?bx+c-expr <- (expr (terms $? ?c-term $?))
    (test (not (eq ?bx-term ?c-term)))   ; simplify by assuming the first one is bx and the second c?
    ?bx-term <- (simple-term (coeff ?b)(var ?var&~nil))
    ?c-term <- (simple-term (coeff ?c)(var nil))
=>
    (bind ?bx-expr (assert (expr (terms ?bx-term))))
    (bind ?c-expr (assert (expr (terms ?c-term))))
    (bind ?abx-term (assert (product-term (factors ?a-expr ?bx-expr))))  ; cleaner would be to keep the existing order
    (bind ?ac-term (assert (product-term (factors ?a-expr ?c-expr))))
    (bind ?new-left-side (assert (expr (terms $?before ?abx-term ?ac-term $?after))))
    (bind ?new-eq (assert (equation (sides ?new-left-side ?right))))
    (bind ?transf (assert (transformation (equation ?new-eq)(to-be-simplified left left)
                								(description distribute * left)(skip-expl-sel2 TRUE))))
    (modify ?prob (cur-transformation ?transf))

    (if (= TRUE ?*trace*) then
        (printout t "Distribute product on the left" crlf)
    		(print-eq ?new-eq)
    		(printout t crlf))
    )

(defrule distribute-right
    ?prob <- (problem (cur-equation ?eq)(cur-transformation nil)(cur-step ~nil))
    ?eq <- (equation (sides ?left ?right))
    ?right <- (expr (terms $?before ?right-product $?after))
    ?right-product <- (product-term (factors $? ?a-expr $?))
    ?right-product <- (product-term (factors $? ?bx+c-expr $?))
    (test (not (eq ?a-expr ?bx+c-expr)))
    ?a-expr <- (expr (terms ?a-term))
    ?a-term <- (simple-term (coeff ?a)(var nil))  ; does it matter that for some probs there is a var of the same name in the wme file?
    ?bx+c-expr <- (expr (terms $? ?bx-term $?))
    ?bx+c-expr <- (expr (terms $? ?c-term $?))
    (test (not (eq ?bx-term ?c-term)))   ; simplify by assuming the first one is bx and the second c?
    ?bx-term <- (simple-term (coeff ?b)(var ?var&~nil))
    ?c-term <- (simple-term (coeff ?c)(var nil))
=>
    (bind ?bx-expr (assert (expr (terms ?bx-term))))
    (bind ?c-expr (assert (expr (terms ?c-term))))
    (bind ?abx-term (assert (product-term (factors ?a-expr ?bx-expr))))  ; cleaner would be to keep the existing order
    (bind ?ac-term (assert (product-term (factors ?a-expr ?c-expr))))
    (bind ?new-right-side (assert (expr (terms $?before ?abx-term ?ac-term $?after))))
    (bind ?new-eq (assert (equation (sides ?left ?new-right-side))))
    (bind ?transf (assert (transformation (equation ?new-eq)(to-be-simplified right right)
                								(description distribute * right)(skip-expl-sel2 TRUE))))
    (modify ?prob (cur-transformation ?transf))

    (if (= TRUE ?*trace*) then
        (printout t "Distribute product on the right" crlf)
    		(print-eq ?new-eq)
    		(printout t crlf))
    )

(defrule swap
    ?prob <- (problem (cur-equation ?eq)(cur-transformation nil)(cur-step ~nil))
    ?eq <- (equation (sides ?left ?right))
=>
    (bind ?new-eq (assert (equation (sides ?right ?left))))
    (bind ?transf (assert (transformation (equation ?new-eq)(description swap * *)))) ; no simplification needed
    (modify ?prob (cur-transformation ?transf))

    (if (= TRUE ?*trace*) then
        (printout t "Swap sides" crlf)
    		(print-eq ?new-eq)
    		(printout t crlf))
    )

(defrule reorder-terms-left    ; issue:  what if the student wants to reorder the side written last?
                          ;    when first side written is the same as previous line, could also be combining like
                          ;    terms on the other side 
                          ; also, what if we do this in the context of simplifying ?? 
                          ; maybe we can use the prov-transformation mechanism?
    ?prob <- (problem (cur-equation ?eq)(cur-transformation nil)(cur-step ~nil)
        					(open-lines ?cur-line $?)(closed-lines ?prev-line $?))    ; pre-explanations nil?
    ?prev-line <- (line (solution-steps ?prev-ie-left ?))
    ?prev-ie-left <- (interface-element (value ?prev-input))
    ?cur-line <- (line (solution-steps ?cur-ie-left ?))
    ?cur-ie-left <- (interface-element (name ?s))
    (studentValues (selection ?sel)(input ?input))
    (test (and (eq ?s (sym-cat ?sel))(algEquivTerms ?prev-input ?input)
            (not (algEquivTermsSameOrder ?prev-input ?input))))  ; reordered
=>
    (bind ?transf (assert (transformation (equation ?eq)(description reorder * *)))) ; no simplification needed
    (modify ?prob (cur-transformation ?transf))

    (if (= TRUE ?*trace*) then
        (printout t "Swap sides" crlf)
    		(print-eq ?new-eq)
    		(printout t crlf))
    )

(defrule done
    (problem (cur-transformation nil)(cur-equation ?eq))
    ?eq <- (equation (sides $? ?s1 $?))
    ?eq <- (equation (sides $? ?s2 $?))
    (test (not (eq ?s1 ?s2)))
    ?s1 <- (expr (terms ?t1))
    ?t1 <- (simple-term (coeff 1)(var ~nil))
    ?s2 <- (expr (terms ?t2))
    ?t2 <- (simple-term (var nil))
=> 
    (predict done ButtonPressed -1)
    (if (= TRUE ?*trace*) then
        (printout t "Done!" crlf)
    		(printout t crlf))
    )

;;-----------------------------------------------------------------------------------------------------------
;;
;; Transformation rules - Flexible strategy
;;

;; TO DO: can it be made not to apply when we are done?  (e.g., x = 3?) 
;; TO DO: split into left and right versions?
;; TO DO: make at least minimally strategic?  (might also help prune the conflict tree)
;; TO DO: what would that be? current side must have an unlike term and other side must have like term or 0? 
;;        works for ax + b = c (can only move b) and ax + b = cx + d (can move any but then are left with only 1 choice)
(defrule move-simple-term    ; move a simple term regardless of whether there is a like
         ; term on the other side - not necessarily strategic;  however, cannot move 0
    (declare (salience 200))
    ?prob <- (problem (cur-equation ?eq)(cur-transformation nil)(cur-step ~nil))
    ?eq <- (equation (sides $? ?side $?))
    ?side <- (expr (terms $?before ?move-term $?after))
    ?move-term <- (simple-term (coeff ?coeff&~0)(var ?var))   ; cannot move 0   (perhaps 0 should not be a term ...)
    ?side <- (expr (terms $? ?unlike-term $?))
    ?unlike-term <- (simple-term (var ?var2&~?var))     ; there is an unlike term on the side being moved from
    ?eq <- (equation (sides $? ?other-side $?))
    (test (neq ?side ?other-side))
    ?other-side <- (expr (terms $? ?like-term-or-zero $?))
    ?like-term-or-zero <- (simple-term (coeff ?coeff2)(var ?var3))
    (test (or (= ?coeff2 0)(eq ?var3 ?var)))    ; other side has like term or is 0
        ; how can we prevent multiple matches for ?like-term-or-zero  
    ?other-side <- (expr (terms $?other-terms))
    ?eq <- (equation (sides ?left ?right))
    ?right <- (expr (terms $?right-terms))
    ?left <- (expr (terms $?left-terms))
=>
    (bind ?new-coeff (* -1 ?coeff))
    (bind ?new-term (assert (simple-term (coeff ?new-coeff)(var ?var))))
    (bind ?new-term-string (term->string ?new-term FALSE  FALSE FALSE))
    	(bind ?new-side (assert (expr (terms $?before ?move-term ?new-term $?after))))
               ; inserts the new term immediately following the term being moved
    (bind ?new-other-side (assert (expr (terms $?other-terms ?new-term))))
               ; inserts the new term at the end (not that it matters much)

    ; now figure out on which side simplification is needed since we are moving a term, simplification is
    ;    needed on the side from which we are moving the term 
    ; now, which side is which? could avoid this by having two rules; would usually not increase
    ;    the conflict tree;  
    (if (eq ?side ?left)
        then (bind ?new-eq (assert (equation (sides ?new-side ?new-other-side))))
             (bind $?simplify (create$ left))
        else (bind ?new-eq (assert (equation (sides ?new-other-side ?new-side))))
        	     (bind $?simplify (create$ right)))
    
    ; does the other side have a like term?  (if so, simplification is needed on that side as well ... hmmm ... 
    ;       what if there were multiple like terms on the other side?)
    ; if other side has zero term, simplification is needed as well, even if it is an unlike term
    (if (< 0 (length$ (filter (lambda (?x) (and (eq (fact-slot-value ?x type) simple-term)
                                                (or (eq (fact-slot-value ?x coeff) 0)
                				                       (eq (fact-slot-value ?x var) ?var))))
                                   ; TO DO: define simple Jess function  var-term-p
              	              $?other-terms)))
        then (bind $?simplify (create$ left right)))   ; otherwise, $?simplify stays what it was
                     ; could be done more smoothly on LHS with simple pattern, see above (at least or the
                     ;     for the case where there is a like term) - would result in two rules but not in a
                     ;     bigger conflict tree because at any time at most one would match 
                     ; --> however, the rule that tests that there is NOT a like term will probably look
                     ;     like the RHS function call here ...  nonetheless, would allow for more
                     ;        fine-grained student modeling, so preferable in that sense?
                     ; --> so could see splitting into 4 or even 5, depending on which direction and whether
                     ;        or not the other side has a like term, does not have a like term, or is 0
                     ; --> and of course could split even further, depending on whether a constant or a
                     ;        variable term is moved

    (bind ?transf (assert (transformation (equation ?new-eq)(to-be-simplified $?simplify)
                			  (description add ?new-term both)
                				)))
    (modify ?prob (cur-transformation ?transf))
    
    (if (= TRUE ?*trace*) then
	    (printout t "Move " (term->string ?move-term FALSE FALSE FALSE) " to the right" crlf)
    		(print-eq ?new-eq)
    		(printout t crlf))
        )


(defrule combine-like-terms-right-flexible   
             ; TO DO: should we have separate rules for combining constants and combining variables? 
             ; this rule works for constant terms and variable terms
             ; would it be better to have one cancel rule that works for both sides?  or start with a maximally granular model?
    ?prob <- (problem (cur-equation ?eq)(cur-transformation nil)(cur-step ~nil))
    ?eq <- (equation (sides ?left ?right))    ; probably won't work in the long run ...
;    ?left <- (expr (terms $?left-terms))
;    ?right <- (expr (terms $?right-terms))
;    (test (simple-terms-only-p$ $?left-terms))
;    (test (simple-terms-only-p$ $?right-terms))    ; to strictly enforce the standard strategy
    ?right <- (expr (terms $?before ?t1 $?between ?t2 $?after))
    ?t1 <- (simple-term (coeff ?c1)(var ?var))
    ?t2 <- (simple-term (coeff ?c2)(var ?var))
=>
    	(bind ?new-term (assert (simple-term (coeff (+ ?c1 ?c2))(var ?var))))
    (bind ?new-right (assert (expr (terms $?before ?new-term $?between $?after))))
    (bind ?new-eq (assert (equation (sides ?left ?new-right))))     ; this step would be more difficult in a rule that works on both sides ...
    (bind ?transf (assert (transformation (equation ?new-eq)
                           (description combine 0 right)(skip-expl-sel2 TRUE))))    ; 0 just a place holder
             ; no intermediate step for combine like terms?
    (modify ?prob (cur-transformation ?transf))
 
    (if (= TRUE ?*trace*) then
        (printout t "Combine like terms " (term->string ?t1 FALSE FALSE FALSE)
            " and " (term->string ?t2 FALSE FALSE FALSE)" on the right" crlf)
    		(print-eq ?new-eq)
    		(printout t crlf))
    )  


;;-----------------------------------------------------------------------------------------------------------
;;
;; Simplification rules
;;
;; These rules capture the simplification steps needed to fully "implement" the main operations.
;; They have in common that they require a transformation fact and modify it.
;; They need to ensure that they only simplify the side of the equation that is in focus (as specified by
;;   the focus slot of the transformation fact).

;; make sure the simplify rules work with the to-be-simplified slot

;; TO DO: why have separate simplify rules for simplifying a var term v. constant term?  (answer: fine-grained modeling)
;; Alternatively, could have separate rules, but move the shared body into a single rule, to avoid the duplication we
;;    have now.
;;
(defrule simplify-eliminate-simple-quotient-var-term-left
        ; if the left side is a single quotient term of the form (d var / d), drop the d's
                ; analogous to the cancel-terms-left
    (problem (cur-transformation ?transf))
    ?transf <- (transformation (equation ?eq)(focus left)(to-be-simplified $?bef left $?aft))
    ?eq <- (equation (sides ?left ?right))
    ?left <- (expr (terms ?left-quotient))
    ?left-quotient <- (quotient-term (factors ?dividend-expr ?divisor-expr))
    ?dividend-expr <- (expr (terms ?dividend-term))
    ?dividend-term <- (simple-term (coeff ?d)(var ?var))
    ?divisor-expr <- (expr (terms ?divisor-term))
    ?divisor-term <- (simple-term (coeff ?d)(var nil)) 
        
=>
    (bind ?new-term-left (assert (simple-term (coeff 1)(var ?var))))
    (bind ?new-left (assert (expr (terms ?new-term-left))))
    (bind ?new-eq (assert (equation (sides ?new-left ?right))))
    (modify ?transf (equation ?new-eq)(to-be-simplified $?bef $?aft))
 
    (if (= TRUE ?*trace*) then
        (printout t "Eliminate quotient on the left side" crlf)
    		(print-eq ?new-eq)
    		(printout t crlf))
    )

(defrule simplify-eliminate-simple-quotient-var-term-right
        ; if the left side is a single quotient term of the form (d var / d), drop the d's
                ; analogous to the cancel-terms-left
    (problem (cur-transformation ?transf))
    ?transf <- (transformation (equation ?eq)(focus right)(to-be-simplified $?bef right $?aft))
    ?eq <- (equation (sides ?left ?right))
    ?right <- (expr (terms ?right-quotient))
    ?right-quotient <- (quotient-term (factors ?dividend-expr ?divisor-expr))
    ?dividend-expr <- (expr (terms ?dividend-term))
    ?dividend-term <- (simple-term (coeff ?d)(var ?var))
    ?divisor-expr <- (expr (terms ?divisor-term))
    ?divisor-term <- (simple-term (coeff ?d)(var nil)) 
        
=>
    (bind ?new-term-right (assert (simple-term (coeff 1)(var ?var))))
    (bind ?new-right (assert (expr (terms ?new-term-right))))
    (bind ?new-eq (assert (equation (sides ?left ?new-right))))
    (modify ?transf (equation ?new-eq)(to-be-simplified $?bef $?aft))
 
    (if (= TRUE ?*trace*) then
        (printout t "Eliminate quotient on the right side" crlf)
    		(print-eq ?new-eq)
    		(printout t crlf))
    )


;; NOTE:  although simplify-divide-left was derived from simplify-divide-right,
;;   its condition is broader
(defrule simplify-divide-constant-term-left   ; if the left side has a quotient term of the form (a / b),
              ; replace it by the quotient
              ; assume integer quotient for now
    (problem (cur-transformation ?transf))
    ?transf <- (transformation (equation ?eq)(focus left)
                				(to-be-simplified $?before left $?after))
    ?eq <- (equation (sides ?left ?right))
    ?left <- (expr (terms ?left-quotient))
    ?left-quotient <- (quotient-term (factors ?dividend-expr ?divisor-expr))
    ?dividend-expr <- (expr (terms ?dividend-term))
    ?dividend-term <- (simple-term (coeff ?a)(var nil))
    ?divisor-expr <- (expr (terms ?divisor-term))
    ?divisor-term <- (simple-term (coeff ?b)(var nil)) 
    (test (= (div ?a ?b)(/ ?a ?b)))    ; checks whether quotient is integer
            ; just so we don't have to deal with the case where it is not
=>
    (bind ?new-coeff (div ?a ?b))
    (bind ?new-term-left (assert (simple-term (coeff ?new-coeff))))
    (bind ?new-left (assert (expr (terms ?new-term-left))))
    (bind ?new-eq (assert (equation (sides ?new-left ?right))))
    (modify ?transf (equation ?new-eq)(to-be-simplified $?before $?after))

    (if (= TRUE ?*trace*) then
	    (printout t "Do the division on the left side" crlf)
    		(print-eq ?new-eq)
    		(printout t crlf))
    )

;; TO DO: broaden this rule so it deal with any simple quotient term on?
;; Or do we need narrow simplify rules for the standard strategy but broader simplify rules for the more
;;     general case?
;;
(defrule simplify-divide-constant-term-right   ; if the right side is a single quotient term of the form (a / b), replace by quotient
              ; assume integer quotient for now
    (problem (cur-transformation ?transf))
    ?transf <- (transformation (equation ?eq)(focus right)
                				(to-be-simplified $?before right $?after))
    ?eq <- (equation (sides ?left ?right))
    ?right <- (expr (terms ?right-quotient))
    ?right-quotient <- (quotient-term (factors ?dividend-expr ?divisor-expr))
    ?dividend-expr <- (expr (terms ?dividend-term))
    ?dividend-term <- (simple-term (coeff ?a)(var nil))
    ?divisor-expr <- (expr (terms ?divisor-term))
    ?divisor-term <- (simple-term (coeff ?b)(var nil)) 
    (test (= (div ?a ?b)(/ ?a ?b)))    ; checks whether quotient is integer
            ; just so we don't have to deal with the case where it is not
=>
    (bind ?new-coeff (div ?a ?b))
    (bind ?new-term-right (assert (simple-term (coeff ?new-coeff))))
    (bind ?new-right (assert (expr (terms ?new-term-right))))
    (bind ?new-eq (assert (equation (sides ?left ?new-right))))
    (modify ?transf (equation ?new-eq)(to-be-simplified $?before $?after))

    (if (= TRUE ?*trace*) then
	    (printout t "Do the division on the right side" crlf)
    		(print-eq ?new-eq)
    		(printout t crlf))
    )

;; can apply twice in one chain  (e.g., 2(x)+2(4)+3x-3=0)
;; how can we avoid generating two chains that only differ in the order in which the two products are dealt with?
(defrule simplify-eliminate-simple-product-left    ; covers both  a*b and ax*b (and commutative variants)
    (problem (cur-transformation ?transf))
    ?transf <- (transformation (equation ?eq)(focus left)(to-be-simplified $?before1 left $?after1))
	(test (not (member$ left $?before1)))   ; just to avoid matches that are essential duplicates
    ?eq <- (equation (sides ?left ?right))
    ?left <- (expr (terms $?before2 ?simple-prod-term $?after2))
    ?simple-prod-term <- (product-term (factors ?expr1 ?expr2))   ; wonder if this level of structure is needed?
    ?expr1 <- (expr (terms ?t1))
    ?t1 <- (simple-term (coeff ?c1)(var ?v1))
    ?expr2 <- (expr (terms ?t2))
    ?t2 <- (simple-term (coeff ?c2)(var ?v2))
    (test (or (eq nil ?v1)(eq nil ?v2)))   ; rule does not deal with quadratic equations
=>
    (bind ?coeff (* ?c1 ?c2))
    (bind ?var (if (eq nil ?v1) then ?v2 else ?v1))  ; note this expression could be nil
    (bind ?new-term (assert (simple-term (coeff ?coeff)(var ?var))))
    (bind ?new-left (assert (expr (terms $?before2 ?new-term $?after2))))
    (bind ?new-eq (assert (equation (sides ?new-left ?right))))
    (modify ?transf (equation ?new-eq)(to-be-simplified $?before1 $?after1))

    (if (= TRUE ?*trace*) then
        (printout t "Eliminate simple product on the left side" crlf)
    		(print-eq ?new-eq)
    		(printout t crlf))
    )

(defrule simplify-eliminate-simple-product-right    ; covers both  a*b and ax*b (and commutative variants)
    (problem (cur-transformation ?transf))
    ?transf <- (transformation (equation ?eq)(focus right)(to-be-simplified $?before1 right $?after1))
	(test (not (member$ right $?before1)))   ; just to avoid matches that are essential duplicates
    ?eq <- (equation (sides ?left ?right))
    ?right <- (expr (terms $?before2 ?simple-prod-term $?after2))
    ?simple-prod-term <- (product-term (factors ?expr1 ?expr2))   ; wonder if this level of structure is needed?
    ?expr1 <- (expr (terms ?t1))
    ?t1 <- (simple-term (coeff ?c1)(var ?v1))
    ?expr2 <- (expr (terms ?t2))
    ?t2 <- (simple-term (coeff ?c2)(var ?v2))
    (test (or (eq nil ?v1)(eq nil ?v2)))   ; rule does not deal with quadratic equations
=>
    (bind ?coeff (* ?c1 ?c2))
    (bind ?var (if (eq nil ?v1) then ?v2 else ?v1))  ; note this expression could be nil
    (bind ?new-term (assert (simple-term (coeff ?coeff)(var ?var))))
    (bind ?new-right (assert (expr (terms $?before2 ?new-term $?after2))))
    (bind ?new-eq (assert (equation (sides ?left ?new-right))))
    (modify ?transf (equation ?new-eq)(to-be-simplified $?before1 $?after1))

    (if (= TRUE ?*trace*) then
        (printout t "Eliminate simple product on the right side" crlf)
    		(print-eq ?new-eq)
    		(printout t crlf))
    )

; require that one of the canceled terms is a new term?  but how do we represent new terms?
;    or will that take care of itself?
; could do so in the transformation fact, I suppose - would not be hard ...
(defrule simplify-cancel-terms-left   ; when there is a term and its negative on the left side, drop both
         ; TO DO: would it be better to have one cancel rule that works for both sides?  
         ; or start with a maximally granular model?
    (problem (cur-transformation ?transf))
    ?transf <- (transformation (equation ?eq)
        				(to-be-simplified $?before1 left $?after1) ; wonder if we need this condition? only to remove left ...
        				(focus left)) 
    ?eq <- (equation (sides ?left ?right))    ; probably won't work in the long run ...
    ?left <- (expr (terms $?before2 ?t1 $?between2 ?t2 $?after2))
    ?t1 <- (simple-term (coeff ?c1)(var ?var))
    ?t2 <- (simple-term (coeff ?c2&:(= ?c2 (* -1 ?c1)))(var ?var))
      ; TO DO (maybe): if the transformation fact contained a slot for new terms, could require that say ?t1 is eql
      ;    bit of reworking of the conditions is needed, but not much ...
=>
    (bind $?new-terms (create$ $?before2 $?between2 $?after2))
    (if (= 0 (length$ $?new-terms))   ; special case: the canceled terms were the only terms left
                                      ; seems overkill to create a separate rule for that special case ...
        then
        (bind $?new-terms (create$ (assert (simple-term (coeff 0))))))
    (bind ?new-left (assert (expr (terms $?new-terms))))
    (bind ?new-eq (assert (equation (sides ?new-left ?right))))
    (modify ?transf (equation ?new-eq)(to-be-simplified $?before1 $?after1))  
 
    (if (= TRUE ?*trace*) then
        (printout t "Cancel terms " (term->string ?t1 FALSE FALSE FALSE) " and " (term->string ?t2 FALSE FALSE FALSE)" on the left" crlf)
    		(print-eq ?new-eq)
    		(printout t crlf))
    )

(defrule simplify-cancel-terms-right   ; when there is a term and its negative on the right side, drop both
    (problem (cur-transformation ?transf))
    ?transf <- (transformation (equation ?eq)
        				(to-be-simplified $?before1 right $?after1) ; wonder if we need this condition? only to remove left ...
        				(focus right)) 
    ?eq <- (equation (sides ?left ?right))    ; probably won't work in the long run ...
    ?right <- (expr (terms $?before2 ?t1 $?between2 ?t2 $?after2))
    ?t1 <- (simple-term (coeff ?c1)(var ?var))
    ?t2 <- (simple-term (coeff ?c2&:(= ?c2 (* -1 ?c1)))(var ?var))
=>
    (bind $?new-terms (create$ $?before2 $?between2 $?after2))
    (if (= 0 (length$ $?new-terms))   ; special case: the canceled terms were the only terms left
                                      ; seems overkill to create a separate rule for that special case ...
        then
        (bind $?new-terms (create$ (assert (simple-term (coeff 0))))))
    (bind ?new-right (assert (expr (terms $?new-terms))))
    (bind ?new-eq (assert (equation (sides ?left ?new-right))))
    (modify ?transf (equation ?new-eq)(to-be-simplified $?before1 $?after1))  
 
    (if (= TRUE ?*trace*) then
        (printout t "Cancel terms " (term->string ?t1 FALSE FALSE FALSE) " and " (term->string ?t2 FALSE FALSE FALSE)" on the right" crlf)
    		(print-eq ?new-eq)
    		(printout t crlf))
    )

; would it be better to have a rule that is aware of which are the new terms and only operates on new terms?
; e.g., when simplifying by combining like terms, require that at least one of the terms is a new term?         
(defrule simplify-combine-like-terms-right   ; should we have separate rules for combining constants and combining variables? 
             ; this rule works for constant terms and variable terms
             ; would it be better to have one cancel rule that works for both sides?  or start with a maximally granular model?
    (problem (cur-transformation ?transf))
    ?transf <- (transformation (equation ?eq)(to-be-simplified $?before1 right $?after1)(focus right))
    ?eq <- (equation (sides ?left ?right))    ; probably won't work in the long run ...
    ?right <- (expr (terms $?before2 ?t1 $?between2 ?t2 $?after2))
    ?t1 <- (simple-term (coeff ?c1)(var ?var))
    ?t2 <- (simple-term (coeff ?c2&:(not (= ?c1 (* -1 ?c2))))(var ?var))  ; like but non-canceling terms
=>
    	(bind ?new-term (assert (simple-term (coeff (+ ?c1 ?c2))(var ?var))))  ; what if ?c1 + ?c2 = 0?
    (bind ?new-right (assert (expr (terms $?before2 ?new-term $?between2 $?after2))))
    (bind ?new-eq (assert (equation (sides ?left ?new-right))))     ; this step would be more difficult in a rule that works on both sides ...
    (modify ?transf (equation ?new-eq)(to-be-simplified $?before1 $?after1))  
    
        (if (= TRUE ?*trace*) then
        (printout t "Combine like terms "
            (term->string ?t1 FALSE FALSE FALSE) " and " (term->string ?t2 FALSE FALSE FALSE)
            " on the right" crlf)
    		(print-eq ?new-eq)
    		(printout t crlf))
    )  

; TO DO: consider replacing these rules with a single (although it may not shrink the conflict tree)
; TO DO: re-factor by breaking out the common part of this rule and the previous?
; TO DO: do we need this one and simplify-cancel-terms-left?  yes, if we use this rule for non-canceling terms
;        though whether that makes sense psychologically, we'll have to see (but seems plausible) 
(defrule simplify-combine-like-terms-left   ; should we have separate rules for combining constants and combining variables? 
             ; this rule works for constant terms and variable terms
             ; would it be better to have one rule that works for both sides?  or start with a maximally granular model?
    (problem (cur-transformation ?transf))
    ?transf <- (transformation (equation ?eq)(to-be-simplified $?before1 left $?after1)(focus left))
    ?eq <- (equation (sides ?left ?right))    ; probably won't work in the long run ...
    ?left <- (expr (terms $?before2 ?t1 $?between2 ?t2 $?after2))
    ?t1 <- (simple-term (coeff ?c1)(var ?var))
    ?t2 <- (simple-term (coeff ?c2&:(not (= ?c1 (* -1 ?c2))))(var ?var))  ; like but non-canceling terms
=>
    	(bind ?new-term (assert (simple-term (coeff (+ ?c1 ?c2))(var ?var))))  ; what if ?c1 + ?c2 = 0?
    (bind ?new-left (assert (expr (terms $?before2 ?new-term $?between2 $?after2))))
    (bind ?new-eq (assert (equation (sides ?new-left ?right))))     ; this step would be more difficult in a rule that works on both sides ...
    (modify ?transf (equation ?new-eq)(to-be-simplified $?before1 $?after1))  
    
        (if (= TRUE ?*trace*) then
        (printout t "Combine like terms "
            (term->string ?t1 FALSE FALSE FALSE) " and " (term->string ?t2 FALSE FALSE FALSE)
            " on the left" crlf)
    		(print-eq ?new-eq)
    		(printout t crlf))
    ) 

(defrule simplify-drop-zero-left   
    (problem (cur-transformation ?transf))
    ?transf <- (transformation (equation ?eq)(to-be-simplified $?before1 left $?after1)(focus left))
    ?eq <- (equation (sides ?left ?right))    ; probably won't work in the long run ...
    ?left <- (expr (terms $?before2 ?zero-term $?after2))
    ?zero-term <- (simple-term (coeff 0))
      ; require a variable term - case of 0 - 9 and such is covered by the simplify-combine ... rules
    ?left <- (expr (terms $? ?var-term $?))
    ?var-term <- (simple-term (var ~nil))
    =>
    (bind ?new-left (assert (expr (terms $?before2 $?after2))))
    (bind ?new-eq (assert (equation (sides ?new-left ?right))))     ; this step would be more difficult in a rule that works on both sides ...
    (modify ?transf (equation ?new-eq)(to-be-simplified $?before1 $?after1))  
    
        (if (= TRUE ?*trace*) then
        (printout t "Drop zero term on the left" crlf)
    		(print-eq ?new-eq)
    		(printout t crlf))
    ) 

(defrule simplify-drop-zero-right   
    (problem (cur-transformation ?transf))
    ?transf <- (transformation (equation ?eq)(to-be-simplified $?before1 right $?after1)(focus right))
    ?eq <- (equation (sides ?left ?right))
    ?right <- (expr (terms $?before2 ?zero-term $?after2))
    ?zero-term <- (simple-term (coeff 0))
      ; require a variable term - case of 0 - 9 and such is covered by the simplify-combine ... rules
    ?right <- (expr (terms $? ?var-term $?))
    ?var-term <- (simple-term (var ~nil))
    =>
    (bind ?new-right (assert (expr (terms $?before2 $?after2))))
    (bind ?new-eq (assert (equation (sides ?left ?new-right))))
    (modify ?transf (equation ?new-eq)(to-be-simplified $?before1 $?after1))  
    
        (if (= TRUE ?*trace*) then
        (printout t "Drop zero term on the right" crlf)
    		(print-eq ?new-eq)
    		(printout t crlf))
    ) 
;;-----------------------------------------------------------------------------------------------------------
;;
;; Rules for testing and debugging
;;

; oddly, this rule keeps fire every cycle of the prod model (are globals reset after each rule firing?)
(defrule print-equation     ; prints equation at the start of solving, just for development purposes
    (declare (salience 1000000))      ; should be higher than for any other rule
    (test (= ?*trace* TRUE))          ; use rule only when developing
    ?prob <- (problem (cur-equation ?eq)(printed FALSE))
=>
	(modify ?prob (printed TRUE))
    (printout t "Given equation" crlf)
    (print-eq ?eq)
    	(printout t crlf))

(defrule enable-pre-explanations
    (declare (salience 100000000))      ; should be higher than for any other rule
    ?p <- (problem (cur-step nil))    ; to prevent proliferation of activations
    (studentValues (input ?student-input))
    (test (eq ?student-input "Pre-Explanations: true"))  ; don't want this in hint cycles, so this is fine
    =>
    (predict checkBoxGroup1 DONT-CARE "Pre-Explanations: true")
    (modify ?p (pre-explanations-p TRUE))    
    (perform-tutor-action "InterfaceAction" "preExpl1Group" "SetVisible" TRUE)
        )

(defrule enable-post-explanations
    (declare (salience 100000000))      ; should be higher than for any other rule
    ?p <- (problem (cur-step nil))    ; to prevent proliferation
    (studentValues (input ?student-input))
    (test (eq ?student-input "Post-Explanations: true"))  ; don't want this in hint cycles, so this is fine
    =>
    (predict checkBoxGroup1 DONT-CARE "Post-Explanations: true")
    (modify ?p (post-explanations-p TRUE))    
    (perform-tutor-action "InterfaceAction" "solve1Group" "SetVisible" TRUE)
        )

(defrule enable-no-explanations
    (declare (salience 100000000))      ; should be higher than for any other rule
    ?p <- (problem (cur-step nil))    ; to prevent proliferation
    (studentValues (input ?student-input))
    (test (eq ?student-input "No Explanations: true"))  ; don't want this in hint cycles, so this is fine
    =>
    (predict checkBoxGroup1 DONT-CARE "No Explanations: true")
    (perform-tutor-action "InterfaceAction" "solve1Group" "SetVisible" TRUE)
        )

(defrule hide-all
    (declare (salience 100000000))      ; should be higher than for any other rule
    ?p <- (problem (cur-step nil)
                   (pre-expl-groups $?pre-expl-groups)
                   (solve-groups $?solve-groups)
                   (post-expl-groups $?post-expl-groups)
                )
    (studentValues (selection "hideButton"))
    =>
    (predict hideButton DONT-CARE DONT-CARE)    ; to stop chaining
    
    (foreach ?g $?pre-expl-groups
        (perform-tutor-action "InterfaceAction" ?g "SetVisible" FALSE))
    (foreach ?g $?solve-groups
        (perform-tutor-action "InterfaceAction" ?g "SetVisible" FALSE))
    (foreach ?g $?post-expl-groups
        (perform-tutor-action "InterfaceAction" ?g "SetVisible" FALSE))
            )

(defrule show-all
    (declare (salience 100000000))      ; should be higher than for any other rule
    ?p <- (problem (cur-step nil)
                   (pre-expl-groups $?pre-expl-groups)
                   (solve-groups $?solve-groups)
                   (post-expl-groups $?post-expl-groups)
                )
    (studentValues (selection "showButton"))
    =>
    (predict showButton DONT-CARE DONT-CARE)    ; to stop chaining
    
    (foreach ?g $?pre-expl-groups
        (perform-tutor-action "InterfaceAction" ?g "SetVisible" TRUE))
    (foreach ?g $?solve-groups
        (perform-tutor-action "InterfaceAction" ?g "SetVisible" TRUE))
    (foreach ?g $?post-expl-groups
        (perform-tutor-action "InterfaceAction" ?g "SetVisible" TRUE))
            )

;;------------------------------------------------------------------------------------------------------
;;
;; Dealing with transformations
;;
;; Explicit representation of transformations is necessary to implement undo and to help with being
;;    flexible and/or configurable with respect to step skipping.
;;


;;
;; maximally flexible would be that intermediate step can be included on left, right, or both
;; so an operation could require three lines (2 intermediate forms --> one intermediate form --> no intermediate forms)
;; 
;; --> but does it really make sense to treat the intermediate forms as different? or is it better to treat
;;   them as any other form of the equation?  (of course, if we want the tutor to insist that students get
;;   rid of the intermediate steps right away, then they should be treated as different)
;;
;; one big advantage of not treating them as different is that we do not need to analyse for each operation
;;    whether or not it has intermediate forms
;;
;; argh
;;
;;
;; model this with focus? i.e., place the rules that deal with intermediate steps in a separate module?
;;

; (defmodule SIMPLIFY)
; this module is entered after a new equation has been created (in the transformation fact in the problem's
;   cur-transformation slot) in its un-simplified (i.e., intermediate) form (but before this equation has been
;   written by the student)
; the idea is to stay in the SIMPLIFY module until the left side and right side have both been written in
;   simplified form, and then to return to the MAIN module so the next operation can be carried out
; --> or should we require only that the simplifying is done, without requiring the writing, so that the model
;   can be flexible in how much step skipping it allows?
; maybe that kind of flexibility is an overambitious goal - the hard part is keeping the writing on the left
;   and right in sync (or so it seems)
;
; how do we know we are done simplifying and writing (so we can pop the focus stack)?  or rely on running
;   out of rule activations?  seems a bit risky ...

; and how do we structure the writing in a line-by-line manner?  introduce a write-transformation subgoal?
; or interpret the transformation fact as such a subgoal?  maybe write-line-subgoal is a better name ... ?
; is the idea that a transformation does not necessarily correspond to a line?

; do we always have a simplify-left and simplify-right subgoal? no, not e.g., if you are multiplying through
;    on one side; so these subgoals have to come from the "main operation rule"  (argh)
; we do always have a write-left and a write-right subgoal, but how do we know we are done simplifying?
; (a write-left subgoal will not be removed when there is still a simplify-left subgoal?)



; focus rules appear to be necessary so that in the chain that writes the left side no simplifications
;    of the right side are done, and vice versa ...
; has lhs sai matching for efficiency

(defrule focus-pre-expl
    (problem (cur-transformation ?transf)(prov-transformation nil)
               (cur-step ~nil)(pre-explanations-p ~nil)(open-lines ?line $?))
    ?transf <- (transformation (focus nil)(pre-explained nil)(skip-expl-sel2 ?skip-sel2))
    ?line <- (line (pre-explanations ?ie1 ?ie2 ?ie3))    ; these need to go in order ...  catch order errors here
    ?ie1 <- (interface-element (value ?v1)(name ?s1))
    ?ie2 <- (interface-element (value ?v2)(name ?s2))
    ?ie3 <- (interface-element (value ?v3)(name ?s3))
        =>
    (bind ?sel (if (eq nil ?v1)
                then ?s1
                else (if (and (eq nil ?v2)(eq nil ?skip-sel2))
                then ?s2
                else ?s3)))
    (predict ?sel NotSpecified NotSpecified)  ; this helps with catching out of order errors when there are multiple
                                              ;     possible transformations
                                              ; Hmmm....  maybe not, since the transformation is created first ...
    (modify ?transf (focus pre-expl))
        )

(defrule focus-left
    (problem (cur-transformation ?transf)(open-lines ?line $?)(cur-step ~nil)(pre-explanations-p ?pre-must))
    ?transf <- (transformation (focus nil)(pre-explained ?pre-done))
    (test (or (eq nil ?pre-must)(not (eq nil ?pre-done))))
    ?line <- (line (solution-steps ?sel ?))
    ?sel <- (interface-element (name ?name1))
    (studentValues (selection ?name2))      ; to keep the conflict tree sparse, especially for wrong answers
                                            ; TO DO: replace by lhs-predict-oa  (or so)
    (test (eq (str-cat ?name1) ?name2))     ; lhs sai check - also encoded on the rhs
=>
    (predict ?name1 NotSpecified NotSpecified)
    	(modify ?transf (focus left))
        )


; has lhs sai matching for efficiency
(defrule focus-right
    (problem (cur-transformation ?transf)(open-lines ?line $?)(cur-step ~nil)(pre-explanations-p ?pre-must))
    ?transf <- (transformation (focus nil)(pre-explained ?pre-done))
    (test (or (eq nil ?pre-must)(not (eq nil ?pre-done))))
    ?line <- (line (solution-steps ? ?sel))
    ?sel <- (interface-element (name ?name1))
    (studentValues (selection ?name2))      ; to keep the conflict tree sparse, especially for wrong answers
    (test (eq (str-cat ?name1) ?name2))     ; lhs sai check - also encoded on the rhs
=>
    (predict ?name1 NotSpecified NotSpecified)
    	(modify ?transf (focus right))
        )

(defrule focus-post-expl
    (problem (cur-transformation ?transf)(open-lines ?line $?)(cur-step ~nil)(post-explanations-p TRUE))
       ; could add the condition that this transformation has not been explained before
       ; this is now taken care of by the write rules, but arguably it is better to handle that in this rule
       ; TO DO:  make focus = post-expl   stay in wm for the next cycle ?    
    ?line <- (line (solution-steps ?s1 ?s2))
    ?s1 <- (interface-element (value ~nil))
    ?s2 <- (interface-element (value ~nil))
       ; the following may be a better way of checking than the three lines above
       ;   hmmm.... maybe we need both
    ?transf <- (transformation (focus nil)(post-explained nil))
       ; cannot do early checking of the selection against student selection (as in focus-left/right) because
       ;     there are three options ... 
       ; TO DO:  is that previous comment based on an assumption that the explanation fields can be filled out
       ;            in any order?
       ; however, not necessary, since only one post-explanation rule will match (or perhaps two) 
=>
    	(modify ?transf (focus post-expl))
        )
;;------------------------------------------------------------------------------------------------------
;;
;; Rules for writing equations
;;

;write-left
;if we're focusing on the left side (focus left checks the left side is open)
;and the left does not still need to be simplified
;    -->  need condition to avoid duplication of a whole line?
;then
;write the left
;mark the simplified form left as written (just in case it had been simplified)
;remove the focus
;(if the line is full move it over to the list of full lines)
;(if both the right and left have been "written" remove transformation) - takes care of the line duplication
(defrule write-left
    ?prob <- (problem (cur-transformation ?transf)(open-lines ?line $?o-lines)
        					(closed-lines $?c-lines)   ; what if there is no next line? include dummy line?
        					(cur-step ?step)(steps $?steps)
        	                (pre-explanations-p ?pre-expl-p)
                	        (post-explanations-p ?post-expl-p)
        )
    ?transf <- (transformation (focus left)(to-be-simplified $?simplify)
        				(written $?written)(equation ?eq)(post-explained ?post-explained))
    (test (not (member$ left $?simplify)))
    ?line <- (line (solution-steps ?sel ?right)(groups ? ? ?post-expl-group))
    ?sel <- (interface-element (value nil))
    ?right <- (interface-element (value ?right-val))
    ?eq <- (equation (sides ?left ?))
    ?prob <- (problem (open-lines ? ?next-line $?))      ; just to grab the next one
    ?next-line <- (line (groups ?next-pre-expl-group ?next-solve-group ?))
        =>
    (bind ?inp (expr->str3 ?left))
    (predict DONT-CARE DONT-CARE ?inp algEquivTerms)
    
    (modify ?sel (value ?*sInput*))
    (modify ?transf (written left $?written)(focus nil))   ; meaning the final (possibly simplified) form has been written
    
    (modify ?step (interface-element ?sel))
    (modify ?prob (cur-step nil)(steps ?step $?steps))
    
    	(if (neq nil ?right-val)  ; if a full equation (left and right side) has been written 
        then
    		(modify ?transf (prev-left-val ?inp)(prev-right-val ?right-val)) 
        (if (or (eq nil ?post-expl-p)(not (eq nil ?post-explained)))
                     ; if post-explanations are not required or have been done already (on a previous line for this transf)
            then
            (modify ?prob (open-lines $?o-lines)(closed-lines ?line $?c-lines))   ; done with the line
            (if (member$ right $?written)   ;  if the right side has also been fully simplified
        		    then
        		    (modify ?prob (cur-transformation nil)(cur-equation ?eq)))))    ; done with the transformation
                    ; TO DO:   retract the transformation?
                    ; TO DO: why is the equation copied from the transformation into the problem fact?

    ; take care of revealing interface elements
    ; if equation is fully written (i.e., left and right, simplified or not)    ; if not fully written, then we do not reveal anything
    ; then (regardless of whether it has been fully simplified)
    ;    if post-explaining and not post-explained, reveal post-explanations on the same line
    ;    if fully simplified and pre-explanations, reveal pre-explanation on the next line
    ;    else reveal solve steps on the next line
    ; NOTE: this assumes we are not simultaneously pre-explaining and post-explaining
  
    (if (neq nil ?right-val)  ; if a full equation (left and right side) has been written 
        then
        (if (and (eq TRUE ?post-expl-p)(eq nil ?post-explained))
            then  (perform-tutor-action "InterfaceAction" ?post-expl-group "SetVisible" TRUE)
            		  (modify ?step (revealed-interface-group ?post-expl-group))
        else (if (and (member$ right $?written)(eq TRUE ?pre-expl-p))  ; fully simplified
            then  (perform-tutor-action "InterfaceAction" ?next-pre-expl-group "SetVisible" TRUE)
                  (modify ?step (revealed-interface-group ?next-pre-expl-group))                
        else  (perform-tutor-action "InterfaceAction" ?next-solve-group "SetVisible" TRUE)
              (modify ?step (revealed-interface-group ?next-solve-group))                                
                )))
    )

;;
;; if we record the (undoable) "state" after these actions in a "state" fact, it would contain 
;; - interface component with value (in the first open row)
;; - list of open and closed components
;; - current equation (this one is tricky, perhaps - do we need a copy)
;; - current transformation (potentially nil)
;;
;; - do we still need to record the prev-left-val and the prev-right-val? I believe these are used to check
;;       the student input is actually a change from the previous row
;; - we'd need this kind of state also for the (non-undoable) initial state ... 

;; could that same fact be used to "do" the step?
;; i.e., create the state fact first, then do the step by "interpreting" that fact?
;; would be great to have a single do-step rule, would be more maintainable ...



(defrule write-right
    ?prob <- (problem (cur-transformation ?transf)(open-lines ?line $?o-lines)(closed-lines $?c-lines)
        					(cur-step ?step)(steps $?steps)
        					(post-explanations-p ?post-expl-p)
        					(pre-explanations-p ?pre-expl-p)
                )
    ?transf <- (transformation (focus right)(to-be-simplified $?simplify)
        			(written $?written)(equation ?eq)(post-explained ?post-explained))
    (test (not (member$ right $?simplify)))
    ?line <- (line (solution-steps ?left ?sel)(groups ? ? ?post-expl-group))
    ?sel <- (interface-element (value nil))
    ?left <- (interface-element (value ?left-val))
    ?eq <- (equation (sides ? ?right))
    ?prob <- (problem (open-lines ? ?next-line $?))      ; just to grab the next one
    ?next-line <- (line (groups ?next-pre-expl-group ?next-solve-group ?))
        =>
    (bind ?inp (expr->str3 ?right))
    (predict DONT-CARE DONT-CARE ?inp algEquivTerms)
    (modify ?sel (value ?*sInput*))
    (modify ?transf (written right $?written)(focus nil))   ; meaning the final (possibly simplified) form has been written

    (modify ?step (interface-element ?sel))
    (modify ?prob (cur-step nil)(steps ?step $?steps))
    
    	(if (neq nil ?left-val)  ; if a full equation (left and right side) has been written 
        then
    		(modify ?transf (prev-left-val ?left-val)(prev-right-val ?inp)) 
        (if (or (eq nil ?post-expl-p)(not (eq nil ?post-explained)))
                     ; if post-explanations are not required or have been done already (on a previous line for this transf)
            then
            (modify ?prob (open-lines $?o-lines)(closed-lines ?line $?c-lines))   ; done with the line
            (if (member$ left $?written)   ;  if the left side has also been fully simplified
        		    then
        		    (modify ?prob (cur-transformation nil)(cur-equation ?eq)))))    ; done with the transformation

      ;; interface stuff
    (if (neq nil ?left-val)  ; if a full equation (left and right side) has been written 
        then
        (if (and (eq TRUE ?post-expl-p)(eq nil ?post-explained))
            then  (perform-tutor-action "InterfaceAction" ?post-expl-group "SetVisible" TRUE)
            		  (modify ?step (revealed-interface-group ?post-expl-group))
            else (if (and (member$ left $?written)(eq TRUE ?pre-expl-p))  ; fully simplified
            then  (perform-tutor-action "InterfaceAction" ?next-pre-expl-group "SetVisible" TRUE)
            		  (modify ?step (revealed-interface-group ?next-pre-expl-group))
            else  (perform-tutor-action "InterfaceAction" ?next-solve-group "SetVisible" TRUE)
            		  (modify ?step (revealed-interface-group ?next-solve-group)))))
        )


;write-intermediate-left
;if we're focusing on the left side (focus left checks the left side is open)
;and we have not written the simplified form yet
;and writing the intermediate form represents progress or  leaves the possibility for progress relative to previous step
;   (i.e., either there is no previous step, or the right side represents progress - meaning, simplified form whereas 
;        the previous line was not - or the right side is open and the right side can be simplified)
;then
;write the intermediate form
;remove the focus
; (if the line if full move it over to the list of full lines)
(defrule write-intermediate-left
    (declare (salience 1000))   ; may help the model tracer be more efficient? depends on students ...
    ?prob <- (problem (cur-transformation ?transf)(open-lines ?line $?o-lines)(closed-lines $?c-lines)
                		  (cur-step ?step)(steps $?steps)(post-explanations-p ?post-expl-p))
    ?transf <- (transformation (focus left)(to-be-simplified $?simplify)
        							(written $?written)(equation ?eq)(post-explained ?post-explained)
        							(prev-left-val ?prev-left-val)(prev-right-val ?prev-right-val))
    (test (member$ left $?simplify))   ; left side is to be simplified, but has not been (fully) yet
    ?line <- (line (solution-steps ?sel ?right)(groups ? ? ?post-expl-group))
    ?sel <- (interface-element (value nil))  ; redundant because focus rule also checks this, but oh well
    ?right <- (interface-element (value ?right-val))
    ?eq <- (equation (sides ?left ?))
    (test (or (eq nil ?prev-right-val)   ; no previous line for this transformation
            	  (neq ?prev-left-val (expr->str3 ?left))  ; current left val different from previous
                             ; happens only when there are multiple simplification steps on the left
                             ;    comparing as strings could be risky?
        		  (and (eq nil ?right-val)   ; haven't filled in the value on the right yet, and the right still needs to be simplified
            	  	   (member$ right $?simplify))
              (and (neq nil ?right-val)  ; right val has been filled in and is different
            		   (not (algEquivTerms ?right-val ?prev-right-val)))  	; comparing as strings could be risky? YES!
        ))
    ?prob <- (problem (open-lines ? ?next-line $?))      ; just to grab the next one
    ?next-line <- (line (groups ? ?next-solve-group ?))
    =>
    (bind ?inp (expr->str3 ?left))
    (predict DONT-CARE DONT-CARE ?inp algStrictEquivTerms)
    
    (modify ?step (interface-element ?sel))
    (modify ?prob (cur-step nil)(steps ?step $?steps))
    
    (modify ?sel (value ?*sInput*))
    (modify ?transf (focus nil))
    	(if (neq nil ?right-val)  ; if a full equation (left and right side) has been written 
        then
    		(modify ?transf (prev-left-val ?inp)(prev-right-val ?right-val)) 
        (if (or (eq nil ?post-expl-p)(not (eq nil ?post-explained)))
                     ; if post-explanations are not required or have been done already (on a previous line for this transf)
            then
            (modify ?prob (open-lines $?o-lines)(closed-lines ?line $?c-lines))   ; done with the line (though not with 
                                                           ; the transformation)
            
        ))
    
    ;; interface stuff - kept separate from the logic above, although somewhat similar
    ;; if equation fully written (left and right, though not fully simplified, at least not on the left)
    ;; then if post-explaining and not post-explained, reveal post-exaplantion steps on same line
    ;; otherwise reveal solve steps on the next line
    ;; (do not need to reveal the next pre-explanation steps because we have not fully simplified yet)

    	(if (neq nil ?right-val)  ; if a full equation (left and right side) has been written 
        then
        (if (and (eq TRUE ?post-expl-p)(eq nil ?post-explained))
            then (perform-tutor-action "InterfaceAction" ?post-expl-group "SetVisible" TRUE)
            		  (modify ?step (revealed-interface-group ?post-expl-group))    
            else (perform-tutor-action "InterfaceAction" ?next-solve-group "SetVisible" TRUE)
            		  (modify ?step (revealed-interface-group ?next-solve-group))))
        )


(defrule write-intermediate-right
    (declare (salience 1000))   ; may help the model tracer be more efficient?
    ?prob <- (problem (cur-transformation ?transf)(open-lines ?line $?o-lines)(closed-lines $?c-lines)
        					(cur-step ?step)(steps $?steps)(post-explanations-p ?post-expl-p))
        ?transf <- (transformation (focus right)(to-be-simplified $?simplify)
        						(written $?written)(equation ?eq)(post-explained ?post-explained)
        						(prev-left-val ?prev-left-val)(prev-right-val ?prev-right-val))
    (test (member$ right $?simplify))   ; right side is to be simplified, but has not been yet
    ?line <- (line (solution-steps ?left ?sel)(groups ? ? ?post-expl-group))
    ?sel <- (interface-element (value nil))  ; redundant because focus rule also checks this, but oh well
    ?left <- (interface-element (value ?left-val))
    ?eq <- (equation (sides ? ?right))
    (test (or (eq nil ?prev-left-val)   ; no previous line for this transformation
              (neq ?prev-right-val (expr->str3 ?right))  ; current right val different from previous
              (and (eq nil ?left-val)   ; haven't filled in the value on the left yet, and the left still needs to be simplified
            	  	   (member$ left $?simplify))
              (and (neq nil ?left-val)
            		   (not (algEquivTerms ?left-val ?prev-left-val))) 
                               ;; TO DO:  should this be algStrictEquivTerms	
        ))
    ?prob <- (problem (open-lines ? ?next-line $?))      ; just to grab the next one
    ?next-line <- (line (groups ? ?next-solve-group ?))
        =>
    (bind ?inp (expr->str3 ?right))
    (predict DONT-CARE DONT-CARE ?inp algStrictEquivTerms)
    
    (modify ?step (interface-element ?sel))
    (modify ?prob (cur-step nil)(steps ?step $?steps))
    
    (modify ?sel (value ?*sInput*))
    (modify ?transf (focus nil))
    	(if (neq nil ?left-val)  ; if a full equation (left and right side) has been written 
        then
    		(modify ?transf (prev-left-val ?left-val)(prev-right-val ?inp)) 
        (if (or (eq nil ?post-expl-p)(not (eq nil ?post-explained)))
                     ; if post-explanations are not required or have been done already (on a previous line for this transf)
            then
            (modify ?prob (open-lines $?o-lines)(closed-lines ?line $?c-lines))   ; done with the line
                        ))
    
        ;; interface stuff
    	(if (neq nil ?left-val)  ; if a full equation (left and right side) has been written 
        then
        (if (and (eq TRUE ?post-expl-p)(eq nil ?post-explained))
            then (perform-tutor-action "InterfaceAction" ?post-expl-group "SetVisible" TRUE)
            		  (modify ?step (revealed-interface-group ?post-expl-group))
            else (perform-tutor-action "InterfaceAction" ?next-solve-group "SetVisible" TRUE)
            		  (modify ?step (revealed-interface-group ?next-solve-group))))
         	)

;; ----------------------------------------------------------------------------------------------------------------
;;
;; Rules for explanations
;;
;; Main idea: the transformation rules fire first, regardless of whether (in the interface) the explanations
;;    come before or after entering the equation. When using pre-explanations, the explanations actually "lock in"
;;    the transformation so that it can be used in the equations steps.
;; So the rules for explanations can be conditioned on a transformation fact.
;;
;; Should model use internal names for the operations, independent of what is in the menus?  Makes it easier to
;;    update the model, if the menus change.
;; So we need explanation facts?
;;
;; Also need to take care of closing lines and of recording enough information so the explanation can be undone.
;; --> Does reset work on the comboboxes?
;;

;; TO DO:  Can we use the same rules for pre-explanations and post-explanations?
;;
;; Separate rules depending on transformation? Yes, this will give more fine-grained data in the logs and
;; although it means there are many more rules, the conflict tree does not grow, because the op is in the lhs
;; of the rules.
;;

(defrule pre-explain-add-op
    (not (explain-op))   ; can have only one at a time
    ?prob <- (problem (cur-transformation ?transf)(open-lines ?line $?)
              (pre-explanations-p TRUE)(cur-step ~nil))
    ?transf <- (transformation (description add ? ?)(focus pre-expl))
    ?line <- (line (pre-explanations ?ie ? ?))
    ?ie <- (interface-element (name ?sel)(value nil))
      ;; TO DO:  lhs test for selection
        =>
    (predict ?sel NotSpecified "Add" add-or-subtract-p)   ; this may not add much?  only when student goes out of order
                                               ; TO DO: cutting this off earlier would be better
                                               ; i.e.,  rule focus-pre-expl could check that the student is looking
                                               ;        at the first open explanation element
                                               ; this is now redundant with focus-pre-expl but that's OK
           ; might as well check input as well
    (assert (explain-op (interface-element ?ie)(input ?*sInput*)(prov-transformation ?transf)))
       ;; TO DO: figure out if the transformation could be used for this instead of the explain-op
    
       ;; Issue: cannot commit to specific transformation yet, because we do not know yet what will be added
       ;;     and there may be multiple possibilities; cannot disambiguate yet (would be nice if we could have
       ;;     multiple interpretations)

       ;; Option 1: retract the transformation?
       ;;     How does one retract a transformation?   We should have a rule for this already, no?
       ;; Option 2: represent the transformation in partially committed state
       ;;     But how to avoid duplication in the rules that create the transformations?
       ;;     How about keeping the partially committed transformation and inserting a rule or rules that check
       ;;         for consistency, with the focus rules waiting until the partially committee transformation
       ;;         has been removed?
       ;;     Would also be nice when re-generating options to only generate ones that are consistent ...
       ;;         Though do that as a next step?
       ;;     And how is this going to work with undo?   Need to be able to restore a partially committed
       ;;         transformation.   Maybe this is not hard.
    
       ;; --> Moving the transformation into provisional status should happen here, because the next rule (enter-step)
       ;;         is a generic rule that does not know anything about when provisional status is appropriate.
       ;;     Actually .... setting the cur-transformation to nil here enables the transformation rules again
       ;;         So next step should move the transformation into provisional status, but should not have to
       ;;         decide whether to do so.
    
    ; (modify ?prob (cur-transformation nil)(prov-transformation ?transf))   ; how about cur-eq????
    )

; Distribute is a provisional transformation because there may be equations where one might distribute on
;    both sides.
(defrule pre-explain-distribute-op
    (not (explain-op))   ; can have only one at a time
    ?prob <- (problem (cur-transformation ?transf)(open-lines ?line $?)
              (pre-explanations-p TRUE)(cur-step ~nil))
    ?transf <- (transformation (description distribute ? ?)(focus pre-expl))
    ?line <- (line (pre-explanations ?ie1 ?ie2 ?))
    ?ie1 <- (interface-element (name ?sel)(value nil))
    ?ie2 <- (interface-element (name ?lock-sel))
      ;; TO DO:  lhs test for selection
        =>
    (predict ?sel NotSpecified "Distribute") 
    (assert (explain-op (interface-element ?ie1)(input ?*sInput*)(prov-transformation ?transf)(lock ?lock-sel)))
    )

(defrule pre-explain-combine-op
    (not (explain-op))   ; can have only one at a time
    ?prob <- (problem (cur-transformation ?transf)(open-lines ?line $?)
              (pre-explanations-p TRUE)(cur-step ~nil))
    ?transf <- (transformation (description combine ? ?)(focus pre-expl))
    ?line <- (line (pre-explanations ?ie1 ?ie2 ?))
    ?ie1 <- (interface-element (name ?sel)(value nil))
    ?ie2 <- (interface-element (name ?lock-sel))
      ;; TO DO:  lhs test for selection
        =>
    (predict ?sel NotSpecified "Combine like terms") 
    (assert (explain-op (interface-element ?ie1)(input ?*sInput*)(prov-transformation ?transf)(lock ?lock-sel)))
    )

; tutor allows Add and Subtract to be used interchangeably;  
; arguably,  "Subtract -4 from both sides" is not a great explanation but accepting it seems fine
; still leaves the question of what the hint should say
(defrule post-explain-add-op
    ?prob <- (problem (cur-transformation ?transf)(open-lines ?line $?)(post-explanations-p TRUE)
                       (cur-step ?step)(steps $?steps))
    ?transf <- (transformation (description add ? ?)(focus post-expl))
    ?line <- (line (post-explanations ?ie ? ?))    ; could tighten this and check that the equation steps are done
    ?ie <- (interface-element (name ?sel)(value nil))  ;  only once - not so important to check but keeps rule from
                                                       ;    being activated unnecessarily
    =>
    (predict ?sel DONT-CARE "Added" add-or-subtract-p)
    (modify ?ie (value ?*sInput*))    ; argh, this seems to be a symbol
         ; make step undoable
    (modify ?step (interface-element ?ie))   ; all rules that write input have this ... TO DO: refactor
    (modify ?prob (cur-step nil)(steps ?step $?steps))
            )

; TO DO:  grow into general  enter-step  rule? 
; Currently, this rule is used only for pre-explanation steps
; Deals with the situation that the choice of operator may not fully constrain the transformation so
;    it is marked as provisional. 

; The enter-pre-explanation rule takes care of some of the details  
(defrule enter-pre-explanation
    ?prob <- (problem (cur-step ?step)(steps $?steps)(cur-transformation ?cur-transf)
                      (open-lines ?line $?))
    ?cur-transf <- (transformation (pre-explained ?pre-explained)(description ?op ? ?))
                       ; not 100% if we can always rely on there being a cur-transformation ?
                       ;    though probably we can
    ?expl <- (explain-op (interface-element ?ie)(input ?inp)(prov-transformation ?prov-transf)(lock ?lock-sel))  
    ?ie <- (interface-element (name ?sel)(value nil))   ; this may be redundant with a previous rule
    ?line <- (line (groups ? ?solve-group ?))   
                  ; group needed when it is time to show the solve group in the interface
        =>
    (predict DONT-CARE DONT-CARE DONT-CARE)     ; this is just to terminate the chain
                      ; selection and input should be checked in the op, num, and sides rules
    (modify ?ie (value ?inp))
         ; make step undoable
    (modify ?step (interface-element ?ie))
    (modify ?prob (cur-step nil)(steps ?step $?steps))
    (modify ?cur-transf (focus nil))
    (if (not (eq nil ?prov-transf))
        then
        (modify ?prob (cur-transformation nil)(prov-transformation ?prov-transf))
        )
        ; this is for pre-explanations only - could store only the descriptio of the transformation but this is fine also
        ; should we retract the ?cur-transf ?  And how is this going to play with undo?
    (retract ?expl)
        ; when the pre-explanation is complete reveal the problem-solving steps in the interface
    (if (not (eq nil ?pre-explained))
        then (perform-tutor-action "InterfaceAction" ?solve-group "SetVisible" TRUE)
             (modify ?step (revealed-interface-group ?solve-group)))
    
        ; for distribute steps, lock the "number" slot
        ; always lock it, even if we did before?
    (if (not (eq nil ?lock-sel))      ; kinda ugly, this special case here
        then
        (perform-tutor-action "InterfaceAction" ?lock-sel UpdateTextField "      ---")
        (perform-tutor-action "InterfaceAction" ?lock-sel lock TRUE))
     )

;; TO DO: split into add and subtract?
(defrule pre-explain-add-constant
    (not (explain-op))   ; can have only one at a time
    ?prob <- (problem (cur-transformation ?transf)(open-lines ?line $?)
                      (pre-explanations-p TRUE)(cur-step ~nil))
    ?transf <- (transformation (description add ?add-term ?)(focus pre-expl))
    ?add-term <- (simple-term (coeff ?num)(var nil))
    ?line <- (line (pre-explanations ?ie1 ?ie2 ?))    ; could tighten this and check that the equation steps are done
    ?ie1 <- (interface-element (value ?op&~nil))  ;  
    ?ie2 <- (interface-element (name ?sel)(value nil))  ;  enforce order
        =>
    (bind ?inp (if (numberp (member$ ?op (create$ "Add" "Added"))) then ?num else (* -1 ?num)))
    (predict ?sel NotSpecified ?inp algEquivTerms )    ; NotSpecificed so we keep chaining
        
    (assert (explain-op (interface-element ?ie2)(input ?inp)))  
       ; Note: transformation is not provisional any more! fully determined by "add" op plus term to be added
            )

; TO DO: split into add and subtract?
(defrule pre-explain-add-var-term
    (not (explain-op))   ; can have only one at a time
    ?prob <- (problem (cur-transformation ?transf)(open-lines ?line $?)
                      (pre-explanations-p TRUE)(cur-step ~nil))
    ?transf <- (transformation (description add ?var-term ?)(focus pre-expl))
    ?var-term <- (simple-term (coeff ?coeff)(var ?var&~nil))
    ?line <- (line (pre-explanations ?ie1 ?ie2 ?))    ; could tighten this and check that the equation steps are done
    ?ie1 <- (interface-element (value ?op&~nil))  ;  
    ?ie2 <- (interface-element (name ?sel)(value nil))  ;  enforce order
        =>
    (bind ?inp-coeff (if (numberp (member$ ?op (create$ "Add" "Added"))) then ?coeff else (* -1 ?coeff)))
    (bind ?inp (str-cat ?inp-coeff ?var))
    (predict ?sel NotSpecified ?inp algEquivTerms)    ; NotSpecificed so we keep chaining
    (assert (explain-op (interface-element ?ie2)(input ?inp)))  ; transformation is not provisional
            )

; need to take into account whether the op is "Add" or "Subtract"
; use separate rules? ...   so we have more ....  :-)  
(defrule post-explain-add-constant
    ?prob <- (problem (cur-transformation ?transf)(open-lines ?line $?)(post-explanations-p TRUE)
                       (cur-step ?step)(steps $?steps))
    ?transf <- (transformation (description add ?add-term ?)(focus post-expl))
    ?add-term <- (simple-term (coeff ?num)(var nil))
    ?line <- (line (post-explanations ?ie1 ?ie2 ?))    ; could tighten this and check that the equation steps are done
    ?ie1 <- (interface-element (value ?op&~nil))  ;  
    ?ie2 <- (interface-element (name ?sel)(value nil))  ;  enforce order
        =>
    (bind ?inp (if (numberp (member$ ?op (create$ "Add" "Added"))) then ?num else (* -1 ?num)))
    (predict ?sel DONT-CARE ?inp num-equal-p  algEquivTerms)
    (modify ?ie2 (value ?inp))
         ; make step undoable
    (modify ?step (interface-element ?ie2))   ; all rules that write input have this ... TO DO: refactor
    (modify ?prob (cur-step nil)(steps ?step $?steps))
            )

(defrule post-explain-add-var-term
    (not (explain-op))   ; can have only one at a time
    ?prob <- (problem (cur-transformation ?transf)(open-lines ?line $?)
                      (post-explanations-p TRUE)(cur-step ~nil))
    ?transf <- (transformation (description add ?var-term ?)(focus post-expl))
    ?var-term <- (simple-term (coeff ?coeff)(var ?var&~nil))
    ?line <- (line (post-explanations ?ie1 ?ie2 ?))    ; could tighten this and check that the equation steps are done
    ?ie1 <- (interface-element (value ?op&~nil))  ;  
    ?ie2 <- (interface-element (name ?sel)(value nil))  ;  enforce order
        =>
    (bind ?inp-coeff (if (numberp (member$ ?op (create$ "Add" "Added"))) then ?coeff else (* -1 ?coeff)))
    (bind ?inp (str-cat ?inp-coeff ?var))
    (predict ?sel NotSpecified ?inp algEquivTerms)    ; NotSpecificed so we keep chaining
          ; algEquivTerms does not consider "x" and "1x" to be equivalent ...
    (assert (explain-op (interface-element ?ie2)(input ?inp)))  ; transformation is not provisional
            )

(defrule post-explain-add-sides
    ?prob <- (problem (cur-transformation ?transf)(open-lines ?line $?open)(closed-lines $?closed)
        			(post-explanations-p TRUE)(cur-step ?step)(steps $?steps))
    ?transf <- (transformation (description add ? ?)(focus post-expl)(written $?written)(equation ?eq))
    ?line <- (line (post-explanations ? ?ie2 ?ie3))    ; could tighten this and check that the equation steps are done
    ?ie2 <- (interface-element (value ~nil))  ;  
    ?ie3 <- (interface-element (name ?sel)(value nil))  ;  enforce order
    ?prob <- (problem (open-lines ? ?next-line $?))
    ?next-line <- (line (groups ? ?next-solve-group ?))
        =>
    (predict ?sel DONT-CARE "to/from both sides")
    (modify ?ie3 (value TRUE))     ; or real student-generated or rule-generated value?
    
    ; update the transformation
    (modify ?transf (post-explained TRUE)(focus nil))
    
    ; close the line
    (modify ?prob (open-lines $?open)(closed-lines ?line $?closed))
    
             ; make step undoable
    (modify ?step (interface-element ?ie3))   ; all rules that write input have this ... TO DO: refactor
    (modify ?prob (cur-step nil)(steps ?step $?steps))

        ; and if necessary, close the transformation (if the simplified form has been written for both sides)
    ; TO DO: refactor
    (if (and (member$ left $?written)(member$ right $?written))
        then
            (modify ?prob (cur-transformation nil)(cur-equation ?eq)))    ; done with the transformation  

    ;; interface stuff   (assume we do not pre-explain and post-explain in the same problem)
    ;; so, done post-explaining means all we need to do is show the next solve group
     (perform-tutor-action "InterfaceAction" ?next-solve-group "SetVisible" TRUE)
     (modify ?step (revealed-interface-group ?next-solve-group))
       )

(defrule pre-explain-add-sides
    ?prob <- (problem (cur-transformation ?transf)(open-lines ?line $?)
        			(pre-explanations-p TRUE)(cur-step ~nil))
    ?transf <- (transformation (description add ? ?)(focus pre-expl))
    ?line <- (line (pre-explanations ? ?ie2 ?ie3))
    ?ie2 <- (interface-element (value ~nil))
    ?ie3 <- (interface-element (name ?sel)(value nil))  ;  order has been dealt with by focus-pre-expl
        =>
    (predict ?sel NotSpecified "to/from both sides")
    (assert (explain-op (interface-element ?ie3)(input "to/from both sides")))
        
    ; update the transformation
    (modify ?transf (pre-explained TRUE))   ; relies on order ... does not check that all three pre-expl steps have been done
    )

(defrule post-explain-divide-op
    ?prob <- (problem (cur-transformation ?transf)(open-lines ?line $?)(post-explanations-p TRUE)
                       (cur-step ?step)(steps $?steps))
    ?transf <- (transformation (description divide ? ?)(focus post-expl))
    ?line <- (line (post-explanations ?ie ? ?))    ; could tighten this and check that the equation steps are done
    ?ie <- (interface-element (name ?sel)(value nil))  ;  only once - not so important to check but keeps rule from
                                                       ;    being activated unnecessarily
    =>
    (predict ?sel DONT-CARE "Divided both sides by" )     ; or real student-generated or rule-generated value?
    (modify ?ie (value ?*sInput*))    ; probably does not matter here whether we have actual student input, but
                                      ;       just to be sure
         ; make step undoable
    (modify ?step (interface-element ?ie))   ; all rules that write input have this ... TO DO: refactor
    (modify ?prob (cur-step nil)(steps ?step $?steps))
            )

(defrule post-explain-distribute-op
    ?prob <- (problem (cur-transformation ?transf)(open-lines ?line $?)(post-explanations-p TRUE)
                       (cur-step ?step)(steps $?steps))
    ?transf <- (transformation (description distribute ? ?)(focus post-expl))
    ?line <- (line (post-explanations ?ie1 ?ie2 ?))    ; could tighten this and check that the equation steps are done
    ?ie1 <- (interface-element (name ?sel1)(value nil))  ;  only once - not so important to check but keeps rule from
                                                       ;    being activated unnecessarily
    ?ie2 <- (interface-element (name ?sel2))
    =>
    (predict ?sel1 DONT-CARE "Distributed" )     ; or real student-generated or rule-generated value?
    (modify ?ie1 (value ?*sInput*))    ; probably does not matter here whether we have actual student input, but
                                      ;       just to be sure
         ; make step undoable
    (modify ?step (interface-element ?ie1))   ; all rules that write input have this ... TO DO: refactor
    (modify ?prob (cur-step nil)(steps ?step $?steps))
       ; hide the "num"  interface element
  ;  (perform-tutor-action "InterfaceAction" ?sel2 "SetVisible" FALSE)
  ;  this causes some trouble, so leave out for now
            )

; TO DO:  is dividing ever a provisional transformation?  meaning there may be multiple ways to divide?
; If so, should create an explain-op fact instead of handling everything here
; Currently, the divide rule is very strict so we do not have that issue (yet) ...
(defrule pre-explain-divide-op
    ?prob <- (problem (cur-transformation ?transf)(open-lines ?line $?)(pre-explanations-p TRUE)
                       (cur-step ?step)(steps $?steps))
    ?transf <- (transformation (description divide ? ?)(focus pre-expl))
    ?line <- (line (pre-explanations ?ie ? ?))    ; could tighten this and check that the equation steps are done
    ?ie <- (interface-element (name ?sel)(value nil))  ;  only once - not so important to check but keeps rule from
                                                       ;    being activated unnecessarily
    =>
    (predict ?sel NotSpecified "Divide both sides by" )
    (assert (explain-op (interface-element ?ie)(input ?*sInput*)))
    )

(defrule post-explain-divide-by-constant
    ?prob <- (problem (cur-transformation ?transf)(open-lines ?line $?)(post-explanations-p TRUE)
                       (cur-step ?step)(steps $?steps))
    ?transf <- (transformation (description divide ?div-term ?)(focus post-expl))
    ?div-term <- (simple-term (coeff ?num)(var nil))
    ?line <- (line (post-explanations ?ie1 ?ie2 ?))    ; could tighten this and check that the equation steps are done
    ?ie1 <- (interface-element (value ~nil))  ;  
    ?ie2 <- (interface-element (name ?sel)(value nil))  ;  enforce order
        =>
    (predict ?sel DONT-CARE ?num algEquivTerms)   ; use of num-equal-p may not be necessary
    (modify ?ie2 (value ?num))
         ; make step undoable
    (modify ?step (interface-element ?ie2))   ; all rules that write input have this ... TO DO: refactor
    (modify ?prob (cur-step nil)(steps ?step $?steps))
            )

;; TO DO:  could re-factor further because this rule is very similar to pre-explain-divide-num ...
(defrule pre-explain-divide-by-constant
    ?prob <- (problem (cur-transformation ?transf)(open-lines ?line $?)(pre-explanations-p TRUE)
                       (cur-step ?step)(steps $?steps))
    ?transf <- (transformation (description divide ?div-term ?)(focus pre-expl))
    ?div-term <- (simple-term (coeff ?num)(var nil))
    ?line <- (line (pre-explanations ?ie1 ?ie2 ?))    ; could tighten this and check that the equation steps are done
    ?ie1 <- (interface-element (value ~nil))  ;  
    ?ie2 <- (interface-element (name ?sel)(value nil))  ;  enforce order
        =>
    (predict ?sel NotSpecified ?num algEquivTerms)   ; NotSpecified so we keep chaining, but the critical test for
          ; selection and input is done here and not repeated later in the chain
    (assert (explain-op (interface-element ?ie2)(input ?num)))
          ; Note: transformation is not provisional!
            )

(defrule post-explain-divide-sides
    ?prob <- (problem (cur-transformation ?transf)(open-lines ?line $?open)(closed-lines $?closed)
        			(post-explanations-p TRUE)(cur-step ?step)(steps $?steps))
    ?transf <- (transformation (description divide ? ?)(focus post-expl)(written $?written)(equation ?eq))
    ?line <- (line (post-explanations ? ?ie2 ?ie3))    ; could tighten this and check that the equation steps are done
    ?ie2 <- (interface-element (value ~nil))  ;  
    ?ie3 <- (interface-element (name ?sel)(value nil))  ;  enforce order
    ?prob <- (problem (open-lines ? ?next-line $?))
    ?next-line <- (line (groups ? ?next-solve-group ?))
            =>
    (predict ?sel DONT-CARE "to/from both sides")
    (modify ?ie3 (value TRUE))     ; or real student-generated or rule-generated value?
    
    ; update the transformation
    (modify ?transf (post-explained TRUE)(focus nil))
    
    ; close the line
    (modify ?prob (open-lines $?open)(closed-lines ?line $?closed))
    
             ; make step undoable
    (modify ?step (interface-element ?ie3))   ; all rules that write input have this ... TO DO: refactor
    (modify ?prob (cur-step nil)(steps ?step $?steps))

        ; and if necessary, close the transformation (if the simplified form has been written for both sides)
    ; TO DO: refactor
    (if (and (member$ left $?written)(member$ right $?written))
        then
            (modify ?prob (cur-transformation nil)(cur-equation ?eq)))    ; done with the transformation
        
    (perform-tutor-action "InterfaceAction" ?next-solve-group "SetVisible" TRUE)
    (modify ?step (revealed-interface-group ?next-solve-group))
        )

(defrule post-explain-distribute-sides
    ?prob <- (problem (cur-transformation ?transf)(open-lines ?line $?open)(closed-lines $?closed)
        			(post-explanations-p TRUE)(cur-step ?step)(steps $?steps))
    ?transf <- (transformation (description distribute ? ?side)(focus post-expl)
                    (written $?written)(equation ?eq))
    ?line <- (line (post-explanations ?ie1 ? ?ie3))    ; could tighten this and check that the equation steps are done
    ?ie1 <- (interface-element (value ~nil))  ;  
    ?ie3 <- (interface-element (name ?sel)(value nil))  ;  enforce order (but skip the "num" field)
    ?prob <- (problem (open-lines ? ?next-line $?))
    ?next-line <- (line (groups ? ?next-solve-group ?))
            =>
    (predict ?sel DONT-CARE ?side sides-equal-p)
    (modify ?ie3 (value TRUE))     ; or real student-generated or rule-generated value?
    
    ; update the transformation
    (modify ?transf (post-explained TRUE)(focus nil))
    
    ; close the line
    (modify ?prob (open-lines $?open)(closed-lines ?line $?closed))
    
             ; make step undoable
    (modify ?step (interface-element ?ie3))   ; all rules that write input have this ... TO DO: refactor
    (modify ?prob (cur-step nil)(steps ?step $?steps))

        ; and if necessary, close the transformation (if the simplified form has been written for both sides)
    ; TO DO: refactor
    (if (and (member$ left $?written)(member$ right $?written))
        then
            (modify ?prob (cur-transformation nil)(cur-equation ?eq)))    ; done with the transformation
        
    (perform-tutor-action "InterfaceAction" ?next-solve-group "SetVisible" TRUE)
    (modify ?step (revealed-interface-group ?next-solve-group))
    )

(defrule pre-explain-divide-sides
    ?prob <- (problem (cur-transformation ?transf)(open-lines ?line $?)
        			(pre-explanations-p TRUE)(cur-step ~nil))
    ?transf <- (transformation (description divide ? ?)(focus pre-expl))
    ?line <- (line (pre-explanations ? ?ie2 ?ie3))
    ?ie2 <- (interface-element (value ~nil))
    ?ie3 <- (interface-element (name ?sel)(value nil))  ;  order has been dealt with by focus-pre-expl
        =>
    (predict ?sel NotSpecified "to/from both sides")
    (assert (explain-op (interface-element ?ie3)(input "to/from both sides")))
        
    ; update the transformation
    (modify ?transf (pre-explained TRUE))   ; relies on order ... does not check that all three pre-expl steps have been done
    )

(defrule pre-explain-distribute-sides
    ?prob <- (problem (cur-transformation ?transf)(open-lines ?line $?)
        			(pre-explanations-p TRUE)(cur-step ~nil))
    ?transf <- (transformation (description distribute ? ?side)(focus pre-expl))
    ?line <- (line (pre-explanations ?ie1 ? ?ie3))
    ?ie1 <- (interface-element (value ~nil))   ; since we skip the middle ie
    ?ie3 <- (interface-element (name ?sel)(value nil))  ;  order has been dealt with by focus-pre-expl
        =>
    (bind ?inp (if (eq ?side left)
                then "to the left side"
                else (if (eq ?side right)
                then "to the right side"
                else "??")))               ; ugly to have this here - should be done once?
    (predict ?sel NotSpecified ?inp)
    (assert (explain-op (interface-element ?ie3)(input ?inp)))
        
    ; update the transformation
    (modify ?transf (pre-explained TRUE))   ; relies on order ... does not check that all three pre-expl steps have been done
    )

;; TO DO: this rule is so similar to the one for dividing ... generalize?
;; also, should we allow combining on both sides at the same time?
;; if not, maybe the menu should be changed?
(defrule pre-explain-combine-sides
    ?prob <- (problem (cur-transformation ?transf)(open-lines ?line $?)
        			(pre-explanations-p TRUE)(cur-step ~nil))
    ?transf <- (transformation (description combine ? ?side)(focus pre-expl))
    ?line <- (line (pre-explanations ?ie1 ? ?ie3))
    ?ie1 <- (interface-element (value ~nil))   ; since we skip the middle ie
    ?ie3 <- (interface-element (name ?sel)(value nil))  ;  order has been dealt with by focus-pre-expl
        =>
    (bind ?inp (if (eq ?side left)
                then "to the left side"
                else (if (eq ?side right)
                then "to the right side"
                else "??")))               ; ugly to have this here - should be done once?
    (predict ?sel NotSpecified ?inp)
    (assert (explain-op (interface-element ?ie3)(input ?inp)))
        
    ; update the transformation
    (modify ?transf (pre-explained TRUE))   ; relies on order ... does not check that all three pre-expl steps have been done
    )

;; Notes re refactoring
;;
;; After a correct action (not an undo)
;; - update wm including transformation (does not generalize)
;; - potentially, update the post-explained slot of the transformation (if there is a single post-explain sides rule
;;             then can be part of that rule)
;;       IF the postOp, postNum, postSides elements have been filled out (do you always need all three?)
;;       THEN set the post-explained slot of the transformation to TRUE
;; - update the undo stack (always)
;; - potentially, show some interface elements on the current line
;;       IF the solveLeft and solveRight elements have been filled in
;;                and student needs to post-explain (i.e., the post-explanations-p slot of the problem is not nil)
;;                and has not post-explained yet (i.e., the post-explained slot of the transformation is nil)
;;       THEN show the postExpl steps
;; - potentially, close the line and show some interface elements on the next line
;;       IF the solveLeft and solveRight elements have been filled in
;;                and student does not need to post-explain (i.e., the post-explanations-p slot of the problem is nil)
;;                    or has post-explained (i.e., the post-explained slot of the transformation is not nil)
;;       THEN close the line and show the solveLeft and solveRight elements on the next line
;; - potentially, close the transformation 
;;       IF the left and right simplified forms have been written
;;                and student does not need to post-explain (i.e., the post-explanations-p slot of the problem is nil)
;;                    or has post-explained (i.e., the post-explained slot of the transformation is not nil)
;;       THEN close the transformation
;;
;; Control structure
;; do all of this in one rule?  mostly on the RHS?
;; or create steps fact and create for each rule a version with the negation of its condition?
;;     - mark-post-explained
;;     - update-undo-stack
;;     - show-elements-cur-line
;;     - close-cur-line
;;     - close-transformation
;; any other options?
;; could write rules such as:
;; IF  next thing to do is mark-post-explained
;; THEN   if we are done post-explaining then set post-explained to TRUE
;;        remove mark-post-explained from the to do list
;;
;; Gives deep model-tracing depth but only happens on correct input, and always succeeds, so perhaps no prob
;; Could use the ACTION element to terminate the chain.
;; Though could wonder if this is really better then the single rule approach ... ?
;;


;; ----------------------------------------------------------------------------------------------------------------
;;
;; Rules for undoing steps
;;
;; In a step
;; - an interface component is filled in (in the first open row)
;; - a row may be closed (i.e., moved from the open to the closed list)
;; - a new row may be revealed in the interface (or part thereof, e.g., the explanation part only or the equation part only)
;; - a transformation may be created or updated
;; - a transformation may be closed
;; - when a transformation is closed, the cur-equation and cur-transformation slot in the problem is updated
;; - when a transformation is created, the cur-transformation slot in the problem is updated

;; To undo a step (i.e., re-create the state that existed prior to it, at the end of the previous step), need to know
;;    the folowing:
;; - interface component that was filled in
;; - interface components that were revealed (or hidden??)
;; - lists of open and closed rows
;; - the current transformation at the beginning of the step
;; - the current equation at the beginning of the step

;; What if the "write" rules created a step element that captures all this state information?
;; Then all the undo rule needs to do is re-store the information.
;;

(defrule record-pre-state
  (declare (salience 100000))     ; maybe this is enough to ensure this rule always goes first?
              ;  safer would be to make all the operations rules have a condition that there is a cur-step
    ?prob <- (problem (cur-step nil)
                     ; (checked-answer-p ~nil)    ; these are key conditions
        				  (open-lines $?ol)(closed-lines $?cl)(cur-equation ?eq)  ; this is just collecting info
                      (cur-transformation ?cur-tr)(prov-transformation ?prov-tr))
    =>
    (bind ?prov-p nil)
    (if (eq nil ?prov-tr)  ; needed when dealing with pre-explanations that specify the transformation in 
                           ;    piecemeal fashion (e.g., adding to both sides is underspecified after the student
                           ;    says "add" until you know what is being added)
        then (bind ?tr ?cur-tr)
        else (bind ?tr ?prov-tr)(bind ?prov-p TRUE))
    (bind ?tr-copy (if (not (eq nil ?tr)) then (copy-transf ?tr) else nil))
    (bind ?eq-copy (if (not (eq nil ?eq)) then (copy-eq ?eq) else nil))
       ; do I need to copy the open and closed lists?  or can they be used as is?  copying is probably better ...
    (bind ?step (assert (step (pre-transformation ?tr-copy)
                				  (pre-closed-list (create$ $?cl))   ; copy the lists ...
                				  (pre-open-list (create$ $?ol))
                			      (pre-equation ?eq-copy)
                				  (provisional-p ?prov-p)
                				)))
    (modify ?prob (cur-step ?step)
           ;       (checked-answer-p nil)      ; for the next cycle
        ))


(defrule undo-step  ; undo the last correct action
    	(declare (salience 2000000))    ; should be tried first

    ?sv <- (studentValues (selection "undo") (action "ButtonPressed"))    ; match only when the action is undo
    
    ?prob <- (problem (steps ?step $?steps))
    ?step <- (step (interface-element ?ie)
            		   (pre-open-list $?open)
    				   (pre-closed-list $?closed)
    				   (pre-transformation ?transf)
    				   (pre-equation ?eq)
        			   (provisional-p ?prov-p)
        			   (revealed-interface-group ?group)
        )
    ?ie <- (interface-element (name ?sel))
        =>
    (predict undo DONT-CARE DONT-CARE)
    (modify ?ie (value nil))
    (modify ?prob (cur-equation ?eq)
        			  (open-lines $?open)
        			  (closed-lines $?closed)
        			  (cur-step nil)      ; probably redundant but good defensive programming
        			  (steps $?steps)
        )
    (if (eq nil ?prov-p)    ; need to restore the transformation as either regular or provisional transformation
    	    then (modify ?prob (cur-transformation ?transf))
        else (modify ?prob (prov-transformation ?transf)(cur-transformation nil)))
    
    (retract ?step)    ; not needed anymore ...
    
    (perform-tutor-action "InterfaceAction" "root" "resetComponentTPA" ?sel)

    (if (neq nil ?group)
        then
		(perform-tutor-action "InterfaceAction" ?group "SetVisible" FALSE))        
    )



;;-------------------------------------------------------------------------------------
;;
;; Bug rules - Yeah!
;;




;;-------------------------------------------------------------------------------------
;;
;; Create facts representing the interface - same for every problem
;; Would be better if these could go in a separate file, but this is the only place for them.
;;

(bind ?ie11 (assert (interface-element (name preExplOp1))))
(bind ?ie12 (assert (interface-element (name preExplNum1))))
(bind ?ie13 (assert (interface-element (name preExplSide1))))
(bind ?ie14 (assert (interface-element (name solveLeft1))))
(bind ?ie15 (assert (interface-element (name solveRight1))))
(bind ?ie16 (assert (interface-element (name postExplOp1))))
(bind ?ie17 (assert (interface-element (name postExplNum1))))
(bind ?ie18 (assert (interface-element (name postExplSide1))))

(bind ?line1 (assert (line (pre-explanations ?ie11 ?ie12 ?ie13)
            				  (solution-steps ?ie14 ?ie15)
                          (post-explanations ?ie16 ?ie17 ?ie18)
            		          (groups preExpl1Group solve1Group postExpl1Group)
            )))

(bind ?ie21 (assert (interface-element (name preExplOp2))))
(bind ?ie22 (assert (interface-element (name preExplNum2))))
(bind ?ie23 (assert (interface-element (name preExplSide2))))
(bind ?ie24 (assert (interface-element (name solveLeft2))))
(bind ?ie25 (assert (interface-element (name solveRight2))))
(bind ?ie26 (assert (interface-element (name postExplOp2))))
(bind ?ie27 (assert (interface-element (name postExplNum2))))
(bind ?ie28 (assert (interface-element (name postExplSide2))))

(bind ?line2 (assert (line (pre-explanations ?ie21 ?ie22 ?ie23)
            				  (solution-steps ?ie24 ?ie25)
                          (post-explanations ?ie26 ?ie27 ?ie28)
                        	  (groups preExpl2Group solve2Group postExpl2Group)
            )))

(bind ?ie31 (assert (interface-element (name preExplOp3))))
(bind ?ie32 (assert (interface-element (name preExplNum3))))
(bind ?ie33 (assert (interface-element (name preExplSide3))))
(bind ?ie34 (assert (interface-element (name solveLeft3))))
(bind ?ie35 (assert (interface-element (name solveRight3))))
(bind ?ie36 (assert (interface-element (name postExplOp3))))
(bind ?ie37 (assert (interface-element (name postExplNum3))))
(bind ?ie38 (assert (interface-element (name postExplSide3))))

(bind ?line3 (assert (line (pre-explanations ?ie31 ?ie32 ?ie33)
            				  (solution-steps ?ie34 ?ie35)
                          (post-explanations ?ie36 ?ie37 ?ie38)
                        	  (groups preExpl3Group solve3Group postExpl3Group)
            )))

(bind ?ie41 (assert (interface-element (name preExplOp4))))
(bind ?ie42 (assert (interface-element (name preExplNum4))))
(bind ?ie43 (assert (interface-element (name preExplSide4))))
(bind ?ie44 (assert (interface-element (name solveLeft4))))
(bind ?ie45 (assert (interface-element (name solveRight4))))
(bind ?ie46 (assert (interface-element (name postExplOp4))))
(bind ?ie47 (assert (interface-element (name postExplNum4))))
(bind ?ie48 (assert (interface-element (name postExplSide4))))

(bind ?line4 (assert (line (pre-explanations ?ie41 ?ie42 ?ie43)
            				  (solution-steps ?ie44 ?ie45)
                          (post-explanations ?ie46 ?ie47 ?ie48)
                        	  (groups preExpl4Group solve4Group postExpl4Group)
            )))

(bind ?ie51 (assert (interface-element (name preExplOp5))))
(bind ?ie52 (assert (interface-element (name preExplNum5))))
(bind ?ie53 (assert (interface-element (name preExplSide5))))
(bind ?ie54 (assert (interface-element (name solveLeft5))))
(bind ?ie55 (assert (interface-element (name solveRight5))))
(bind ?ie56 (assert (interface-element (name postExplOp5))))
(bind ?ie57 (assert (interface-element (name postExplNum5))))
(bind ?ie58 (assert (interface-element (name postExplSide5))))

(bind ?line5 (assert (line (pre-explanations ?ie51 ?ie52 ?ie53)
            				  (solution-steps ?ie54 ?ie55)
                          (post-explanations ?ie56 ?ie57 ?ie58)
                        	  (groups preExpl5Group solve5Group postExpl5Group)
            )))

(bind ?ie61 (assert (interface-element (name preExplOp6))))
(bind ?ie62 (assert (interface-element (name preExplNum6))))
(bind ?ie63 (assert (interface-element (name preExplSide6))))
(bind ?ie64 (assert (interface-element (name solveLeft6))))
(bind ?ie65 (assert (interface-element (name solveRight6))))
(bind ?ie66 (assert (interface-element (name postExplOp6))))
(bind ?ie67 (assert (interface-element (name postExplNum6))))
(bind ?ie68 (assert (interface-element (name postExplSide6))))

(bind ?line6 (assert (line (pre-explanations ?ie61 ?ie62 ?ie63)
            				  (solution-steps ?ie64 ?ie65)
                          (post-explanations ?ie66 ?ie67 ?ie68)
                        	  (groups preExpl6Group solve6Group postExpl6Group)
            )))

(bind ?ie71 (assert (interface-element (name preExplOp7))))
(bind ?ie72 (assert (interface-element (name preExplNum7))))
(bind ?ie73 (assert (interface-element (name preExplSide7))))
(bind ?ie74 (assert (interface-element (name solveLeft7))))
(bind ?ie75 (assert (interface-element (name solveRight7))))
(bind ?ie76 (assert (interface-element (name postExplOp7))))
(bind ?ie77 (assert (interface-element (name postExplNum7))))
(bind ?ie78 (assert (interface-element (name postExplSide7))))

(bind ?line7 (assert (line (pre-explanations ?ie71 ?ie72 ?ie73)
            				  (solution-steps ?ie74 ?ie75)
                          (post-explanations ?ie76 ?ie77 ?ie78)
                        	  (groups preExpl7Group solve7Group postExpl7Group)
            )))

(bind ?ie81 (assert (interface-element (name preExplOp8))))
(bind ?ie82 (assert (interface-element (name preExplNum8))))
(bind ?ie83 (assert (interface-element (name preExplSide8))))
(bind ?ie84 (assert (interface-element (name solveLeft8))))
(bind ?ie85 (assert (interface-element (name solveRight8))))
(bind ?ie86 (assert (interface-element (name postExplOp8))))
(bind ?ie87 (assert (interface-element (name postExplNum8))))
(bind ?ie88 (assert (interface-element (name postExplSide8))))

(bind ?line8 (assert (line (pre-explanations ?ie81 ?ie82 ?ie83)
            				  (solution-steps ?ie84 ?ie85)
                          (post-explanations ?ie86 ?ie87 ?ie88)
                        	  (groups preExpl8Group solve8Group postExpl8Group)
            )))

(bind ?ie91 (assert (interface-element (name preExplOp9))))
(bind ?ie92 (assert (interface-element (name preExplNum9))))
(bind ?ie93 (assert (interface-element (name preExplSide9))))
(bind ?ie94 (assert (interface-element (name solveLeft9))))
(bind ?ie95 (assert (interface-element (name solveRight9))))
(bind ?ie96 (assert (interface-element (name postExplOp9))))
(bind ?ie97 (assert (interface-element (name postExplNum9))))
(bind ?ie98 (assert (interface-element (name postExplSide9))))

(bind ?line9 (assert (line (pre-explanations ?ie91 ?ie92 ?ie93)
            				  (solution-steps ?ie94 ?ie95)
                          (post-explanations ?ie96 ?ie97 ?ie98)
                        	  (groups preExpl9Group solve9Group postExpl9Group)
            )))

(bind ?this-problem
    (assert (problem (open-lines ?line1 ?line2 ?line3 ?line4 ?line5 ?line6 ?line7 ?line8 ?line9)
        )))

(modify ?this-problem
    (pre-expl-groups      ; stores the names of the groups in the interface - used for showing and hiding them all
                                     ; mostly needed for testing with going back to the start state, but
                                     ; this is essentially a workaround
                                     ; TO DO: perhaps work with some custom actionscript?
        (create$ preExpl1Group preExpl2Group preExpl3Group
                 preExpl4Group preExpl5Group preExpl6Group
                 preExpl7Group preExpl8Group preExpl9Group)
            )
    (solve-groups  
        (create$ solve1Group solve2Group solve3Group
                 solve4Group solve5Group solve6Group
                 solve7Group solve8Group solve9Group)
            )
    (post-expl-groups
        (create$ postExpl1Group postExpl2Group postExpl3Group
                 postExpl4Group postExpl5Group postExpl6Group
                 postExpl7Group postExpl8Group postExpl9Group)
            ))


;; Turn on explanations  --  currently done by rules, since that is more convenient for testing
;(modify ?this-problem 
    ; (pre-explanations-p TRUE)
    ; (post-explanations-p TRUE)
;    )
