_global.simroot.state1 = .5;var  myListener1:Object = new Object(); myListener1.changeParam = function(param1:String,param2:Number, param3:Number, param4:Object, x , y, Xoffset, Yoffset,param5) { //param1 is the name of the value to be changed//param2 is it's new value//param3 is the ID of the molecule //param4 is the object reference to the prototype array of molecule being modified//param5 is the prototype object for the molecule that the ligand is binding to//x,y,offset location to create//_root.myBroadcaster.broadcastMessage("changeParam", "M*",Number(thenumber),moleculeID,myprototype); //here we just want to change other parameters of the system.  if ((param1=="k") or (param1=="Kd") or (param1=="M*") or (param1=="M**") or(param1=="M+") or (param1=="Kcat")){		trace("changeParam="+param1);		if (param1=="M*") {// removes all ligand and adds back a different number			//  <action event="sendmessage" name="box1" params="msg=changeParam,param1=M*,param2=50,param3=2"/>				prototype = param4;//molecule[param3];//param4//;["molecule"+2];//_parent["molecule"+param3];  //                                                              DIANA - we need to go back to calculating a delta and specifying remove some and add a few more vs remove all create more 					if (prototype.numMoleculesOnstage>0 ) {				//trace("<<<<Removing all from stage="+prototype.numMoleculesOnstage);					removeLigands (param3,prototype.numMoleculesOnstage);					//trace("these objects="+this.objectContainer5.length);			}			if (param2>0) {				//trace("=>=>=>=> name of what we are looking for="+param1+" new value="+param2+" id of molecule param3="+param3+"  prototype="+prototype+"  current number="+prototype.numMoleculesOnstage+"  mybounce="+prototype.mybounce);				addLigands(param3,Number(param2),Number(prototype.x),Number(prototype.y),Number(prototype.Xoffset),Number(prototype.Yoffset),prototype.mybounce);				//trace("added "+param2+"  to stage="+prototype.numMoleculesOnstage);							}			   		}    //end if Param1="M*"		if (param1=="M**") {			//  <action event="sendmessage" name="box1" params="msg=changeParam,param1=M*,param2=50,param3=2"/>				prototype = param4;//molecule[param3];//param4//;["molecule"+2];//_parent["molecule"+param3];  				prototype2 = param5;/*The expression for the amount of ligand to add to the beaker should be this:L_tot = L_free + ML, where ML is the amount of protein-ligand complex.	_root.myBroadcaster.broadcastMessage("changeParam", thechangeParam,Number(thenumber),ligandID,myprototype1["molecule"+ligandID],"","","","",myprototype1["molecule"+moleculeID]);	param4 = myprototype1["molecule"+ligandID]	param5 = myprototype1["molecule"+moleculeID]ML = M_tot * L_free/(L_free + Kd), where M_tot is the total number of macromolecules.  Kd is the ratio of the off-rate/on-rate.  I think we will have to calibrate this to get the appropriate behavior. I recall a calibration factor of 50, but I'm not sure what that was from. GordonWe want to add a new amount within the bag as well as the Lfree amount outside the bag*/		L_free = param2;		Kd = Number(prototype.bindswith[0].Kd);		ML = prototype2.numMoleculesOnstage * L_free/(L_free + Kd);		L_tot = Math.floor(L_free + ML); 			if (prototype.numMoleculesOnstage>0 ) {				trace("<<<<Removing all from stage="+prototype.numMoleculesOnstage);					removeLigands (param3,prototype.numMoleculesOnstage);					trace("these objects="+this.objectContainer5.length);			}			if (param2>0) {				addLigands(param3,L_tot,Number(prototype.x),Number(prototype.y),Number(prototype.Xoffset),Number(prototype.Yoffset),prototype.mybounce);				addLigands(param3,param2,20,20,10,10,prototype.mybounce);			//trace("name of what we are looking for="+param1+" new value="+param2+" id of molecule param3="+param3+"  prototype="+prototype+"  current number="+prototype.numMoleculesOnstage);				//trace("added "+L_tot+"  to stage="+prototype.numMoleculesOnstage);				LINbag (L_tot);							}			   		}    //end if Param1="M**"   		if (param1=="M+") {			//  <action event="sendmessage" name="box1" params="msg=changeParam,param1=M*,param2=50,param3=2"/>			prototype = param4; 			//trace("current values 1,2,3="+ prototype.numMoleculesOnstage+","+_level0.box1["objectContainer"+2].numMoleculesOnstage+","+_level0.box1["objectContainer"+3].numMoleculesOnstage);			if (x != undefined) {				trace("adding at="+param2+">> "+param3);				addLigands(param3,Number(param2),Number(x),Number(y),Number(Xoffset),Number(Yoffset),prototype.mybounce);			} else {				addLigands(param3,Number(param2),prototype.x,prototype.y,prototype.Xoffset,prototype.Yoffset,prototype.mybounce);			}}    if (param1=="Kcat"){//DIANA		param4["bindswith"][0].Kcat = Number(param2); //reset the parameter for the prototype	   for (thisMolecule in   _level0.box1["objectContainer"+param3]){		  // trace("resetting Kcat = "+param2+"  for ligand="+ _level0.box1["objectContainer"+param3][thisMolecule]["bindswith"][0].t);		   if (_level0.box1["objectContainer"+param3][thisMolecule]["bindswith"][0].t!=undefined) {	  	  	_level0.box1["objectContainer"+param3][thisMolecule]["bindswith"][0].Kcat = Number(param2)// reset Kcat for this molecule		   }	   }	    }   } else { 	set (param1, param2); //	trace("resetting "+param1 +" to "+param2);};/*We need to rewrite how the objects all get updated    //now update the objects   for (i=0;i<maxMolecules;i++) {	//first the ligands 	tempVal =objContainer["molecule" + i].myID;	temp2 = Eval("moleculeVelocity"+tempVal);	objContainer["molecule" + i].magnitude = myRandom(temp2-10,temp2+10);	objContainer["molecule" + i].mybindingstrength = Number(this.k.text.text)/Number(this.Kd.text.text);//Number(bindstrength.text.text);	// how strongly ligands bind to me	 objContainer["molecule" + i].moveX = Math.cos(objContainer["molecule" + i].direction) * objContainer["molecule" + i].magnitude;	objContainer["molecule" + i].moveY = Math.sin(objContainer["molecule" + i].direction) * objContainer["molecule" + i].magnitude;	}      for (i=0;i<maxLigands;i++) {	//first the ligands 	tempVal =objContainer["molecule" + i].myID;	temp2 = Eval("ligandVelocity"+tempVal);	//trace("Setting new velocity for ligand="+tempVal+"from "+objContainer["ligand" + i].magnitude+" to  = "+temp2);	 objContainer["molecule" + i].magnitude = myRandom(temp2-10,temp2+10);	 objContainer["molecule" + i].moveX = Math.cos(objContainer["molecule" + i].direction) * objContainer["molecule" + i].magnitude;	objContainer["molecule" + i].moveY = Math.sin(objContainer["molecule" + i].direction) * objContainer["molecule" + i].magnitude;   }   */}myListener1.changeVal = function(param1:String,param2:Number) { //param1 is the name of the value to be changed//param2 is it's new valueif (param1== "state1") {	_root.state1 = param2;	//trace("fraction in state1 = "+param2+"  "+_root.state1);}}this._parent.myBroadcaster.addListener(this.myListener1); function pause() {	_global.movepause = true;}function resume() {	_global.movepause = false;}function sendmessage(params) {	//the set of paramaters will be parsed in the name=value pairs and used to assemble a broadcast message command	theparams = params.split(",");	for (i=0; i<theparams.length;i++) {		temp = theparams[i].split("=");		this[temp[0]]=temp[1];	}	//if (this.msg=="pause") {//DIANA I think this.msg is not being used		//_global.movepause = true;		//} else {	trace("sendmessage called "+this.msg+"/"+this.param3);	this._parent.myBroadcaster.broadcastMessage(this.msg, this.param1,this.param2,this.param3,this,this.x,this.y,this.Xoffset,this.Yoffset);			//DIANA figure out how to construct the above message		//}}var voice=new Sound();voice.attachSound("t1") // ### set up legal movement area for inner regionvar leftBorder:Number;var rightBorder:Number;var topBorder:Number;var bottomBorder:Number;var leftBorder2:Number;var rightBorder2:Number;var topBorder2:Number;var bottomBorder2:Number;/*I need to change all of the setable parameters to be param boxesalso when a ligand binds it needs to select the correct Toff(bindingstrength)*/_global.movepause=false;// ### set whether clips bounce or wrap when they hit the wallsfunction LINbag (L_tot) {	this._parent.myBroadcaster.broadcastMessage("changeVal","LINBag", L_tot);}// ### kill the attached objectsfunction kill () {		this._parent.myBroadcaster.removeListener(this.myListener1);  		unloadMovie(this);}//Function to remove all the molecules created for this IDfunction reset (thisID) {	//trace("reset for "+this["molecule" + thisID].mytype);	if (this["molecule" + thisID].mytype=="ligand") {		removeLigands(thisID,this["molecule"+thisID].numMoleculesOnstage);	} else {		removeMolecules(thisID,this["molecule"+thisID].numMoleculesOnstage);	}}function restart() {	//need to loop through the prototypes and kill who is on stage and then reinstantiate them	trace("***********************restarting ligand box with vars "+_root.saveparams+" | "+_root.savedata+" | "+_root.SaveXMLMolecules);	//reset();	initialize(_root.saveparams,_root.savedata,_root.SaveXMLMolecules);}/* ### create objects and bordersnumMolecules,numMolecules2,numLigands - these values will not come in through the initialization - but will be loaded from the inputs object*/function initialize (params,data,XMLmolecules) {	_root.saveparams = params;	_root.savedata = data;	_root.SaveXMLmolecules = XMLmolecules;	theparams = params.split(",");	for (var i=0; i<theparams.length;i++) 	{		temp = theparams[i].split("=");		if((temp[0]=="k") or (temp[0]=="Kd")) {			    if (temp[0]=="k") {					this.k.text.text = Number(temp[1]);				} else {					this.Kd.text.text = Number(temp[1]);				}		} else {			if (isNaN(Number(temp[1])) ) {				this[temp[0]] = temp[1];			} else {				this[temp[0]] = Number(temp[1]);			} //end isNan test						this._parent.myBroadcaster.broadcastMessage("reset", temp[0], temp[1]);							}	}  // end for	//now get the molecule prototypes loaded		for (var m=0; m<XMLmolecules.length;m++) {////I NEED TO FUGURE OUT HOW TO COUNT THESE		thismolecule=XMLmolecules[m]; //this is a pointer to one of the molecules specifies by author		//trace("thismolecule="+thismolecule);		myID = thismolecule["myID"]; //pick up the ID number for this class of molecules to store properties into prototype		prototype = this["molecule"+myID]; //create a reference to the correct prototype array		for (var j in XMLmolecules[m]) {//this loops through the attributes of this molecule and transfers the values to the prototype			prototype[j]=thismolecule[j];			//trace(j+":"+prototype[j]);		}		prototype.maxMolecule=0;   //we also initialize some counters		prototype.numBound=0;		prototype.numFree=0;		prototype.totals0=0;		prototype.totals1=0;		prototype.totals2=0;		prototype.numFolded=0;		prototype.numMoleculesOnstage=0		prototype.myclock = -1;		prototype.myfreedomclock = -1;				//trace(">>>>>>>>>>>>>>>>>>initial params for      prototype="+prototype+"   prototype.totals0"+prototype.totals0);//if bindswith is set for the prototype - parse it's values				if (prototype.bindswith != undefined) {				myInteractions = prototype.bindswith.split("&");				delete prototype.bindswith; //zap the incoming then parse				prototype.bindswith = new Array();				for (var i =0; i<myInteractions.length;i++) {	//array will contains the child descriptions of these interactions				thisinteraction = myInteractions[i].split(","); 	 //the various parameters of this interaction seperated by ","//interactions:        bindswith="molecule1.pocket1.bound1,Kd?A-J:50|K-M:20|N-S:10|T-Z:25,k?500&molecule1.pocket1.bound1,Kd?50,k?500"//FOR NOW WE ARE ONLY DOING BINDSWITH SO I WON'T ADD THE TEST FOR ANYTHING ELSE			//seperate this into molecule and pocket//trace("this interactions binding site="+thisinteraction[0]+"  and its params="+thisinteraction[1]+"/"+thisinteraction[2]);				MyParts = thisinteraction[0].split(".");			//trace("MyParts="+mybindswith[1]);					myt = MyParts[0].substr(8,2); //pick up molecule type					p = MyParts[1].substr(6,2); //pick up which pocket					mv = MyParts[2]; //pick up which pocket view (molecule)					b = MyParts[3]; //pick up which pocket view (ligand)					//trace("parsing interactions bindswith="+thisinteraction[1]+"  ="+myt+"."+p+"."+mv+"."+b);					for (var j=1; j<thisinteraction.length; j++) {						temp = thisinteraction[j].split("?");												switch (temp[0]) {  						case "Kd" :  							myKd =this._parent.ReturnUserValue(this._parent.lastname,temp[1]) ; 							break;  						case "k" : 							myk = this._parent.ReturnUserValue(this._parent.lastname,temp[1]) ; 							break;  						case "Kcat" : 							myKcat = this._parent.ReturnUserValue(this._parent.lastname,temp[1]) ;							break; 						case "productidl" :   //this is the ligand product when seperates							myproductidl = temp[1];							break; 						case "productidm" :  //this is the molecule it becomes when it seperates							myproductidm = temp[1];							break; 							case "productidp" :  //this is the molecule it becomes when it seperates							myproductidp = temp[1];							break; 						/*case "bound" :  //this is the molecule it becomes when it seperates							myboundInitially = temp[1];							break; 							*/						}  //end switch					} //end of for loop - hope everybody is defined.					prototype.bindswith.push( {t:myt,p:p,mv:mv,b:b,Kd:myKd,k:myk,Kcat:myKcat,productidm:myproductidm,productidl:myproductidl,productidp:myproductidp}); //,bound:myboundInitially});	//trace("prototype.bindswith="+prototype.bindswith);				} //end for looping through binding sites		}//endof if bindswith defined				//if inhibits is set for the prototype - parse it's values				if (prototype.interactions != undefined) {				var interactionarray = new Array();						myInteractions = prototype.interactions.split("&");//if more than one on a line				delete prototype.interactions; //zap the incoming then parse				prototype.interactions = new Array();				for (var i =0; i<myInteractions.length;i++) {	//array will contains the child descriptions of these interactions						  thisinteraction = myInteractions[i].split(","); 	 //the various parameters of this interaction seperated by ","							for (var j=0; j<thisinteraction.length; j++) {//this loops through the interactions entry data						MyParts = thisinteraction[j].split("=");						switch (MyParts[0]) { //check each part and simplify 						case "master" : 							mymp = MyParts[1]; 							break; 						case "slave" : 							mysp = MyParts[1]; 							break; 						case "effect" : 							myeffect = MyParts[1]; 							break; 						};								} // end looping through this interaction definition					prototype.interactions.push({mp:mymp,sp:mysp,effect:myeffect});				} //end for looping through interaction sites		}//endof if interactions defined					if (prototype.polarity != undefined) { //if this is defined then pass it along as an array			prototype.polarity = prototype.polarity.split(",");				}  //close if polarity is defined//loop through the seperateinto interaction definitions			if (prototype.seperateinto != undefined) {					//set aside and parse this value and replace raw one			tempseperateinto = prototype.seperateinto;			newarray = new Array();			delete prototype.seperateinto;  //remove this current data and parse			myparents = tempseperateinto.split(",");								for (var i =0; i<myparents.length;i++) {	//array will contains the child descriptions of these interactions				thisparent = myparents[i].split("?"); 				newarray[thisparent[0]] = this._parent.ReturnUserValue(this._parent.lastname,thisparent[1]);				trace(thisparent[0]+"  "+newarray[thisparent[0]]);			} //close for i					prototype.seperateinto = newarray;			//prototype.seperateinto.push(newarray); //Diana 12/15/08			//trace("prototype seperateinto="+newarray);		}  //close if seperateinto is defined		//trace("prototype="+prototype.Xoffest+","+prototype.Yoffset);	} //for loop on m finish defining the object prototypes	//we also want to describe the environment type specifying whether there are//1, two, or three divisions to keep counts forthis.envtype = 0;//if only one of the inner and outer borders collide we are also of type 0//so look for the special case of left and right or top and bottoms collidingif (leftBorder==leftBorder2 and rightBorder==rightBorder2) {	if ((topBorder!=topBorder2) or (bottomBorder!=bottomBorder2)) {		//trace("my envtype=1");		this.envtype = 1;	}}if (topBorder==topBorder2 and bottomBorder==bottomBorder2) {	if ((leftBorder!=leftBorder2) or (rightBorder!=rightBorder2) ){		this.envtype = 2;	}}			//this.mybounce = Boolean(this.mybounce);	_global.movepause = Boolean(this.pause);	// create a container clip to hold the objects	//attachMovie("emptyClip", "objContainer", 0);	//numMolecules1 = _root[eq1].num_E.text.text;	//numMolecules2= 0; //we don't have an input box for this yet	//numLigands = _root[eq1].num_S.text.text;;	//_root[eq2].num_E.text.text=Number(numMolecules1); //needs to be same as eq1	// create and initialize the Molecule objects//	for ( var t=0;t<XMLmolecules.length; t++) {  //loop through the kinds of molecules being created		for ( var t=0;t<11; t++) {  //loop through the kinds of molecules being created//newset = "objContainer"+t;	//thisObjectContainer = origin.attachMovie("emptyClip",newset , 0); //create a parent object for this class of cast member	//thisObjectContainer._x=0;	//thisObjectContainer._y=0;//trace("created object t="+t);	if (true) { //Boolean(this["molecule"+t].mybounce)==true) { //create free floating proteins***DIANA add attached codes		//offset = maxMolecules;			 	for (var i=0; i < this["molecule"+t].numMolecules; i++) {				//trace("   created object t="+i);			newname = "molecule"+this["molecule"+t].maxMolecule;			newbounce = this["molecule"+t].mybounce;			newlevel = this["molecule"+t].maxMolecule;			this["molecule"+t].maxMolecule = this["molecule"+t].maxMolecule+1;   //bump the name counter - also used for level.			if (Boolean(this["molecule"+t].Xalign)) { 					newX = Number(this["molecule"+t].x)+Number(this["molecule"+t].Xoffset)*i;					Xoffset = 0;			} else {					newX = Number(this["molecule"+t].x);					Xoffset = Number(this["molecule"+t].Xoffset);			}			if (Boolean(this["molecule"+t].Yalign)) { 					newY = Number(this["molecule"+t].y)+Number(this["molecule"+t].Yoffset)*i;					Yoffset = 0;			} else {					newY = Number(this["molecule"+t].y);					Yoffset = Number(this["molecule"+t].Yoffset);			}			//trace("about to create="+newX+","+newY+","+Xoffset+","+Yoffset+"  newbounce="+newbounce);			Create1Molecule(t,newname,newlevel,newX,newY,Xoffset,Yoffset,newbounce);  //-1 indicated totally random X,Y and delta							}	} else { //create attached proteins		//trace("creating attached molecules");	/*	This code probably no longer works - but I am keeping it here just to understand what conditions create	the behavior this code is supposed to create		*/				//offset = maxMolecules;							for (var i=0; i < this["molecule"+t].numMolecules; i++) { //bottom bound membrane			newname = "molecule"+i;			newlevel =  -Number(t*1000+i);			newOne = this["objectContainer"+t].attachMovie(this["molecule"+t].cast, newname, newlevel);			//maxMolecules = maxMolecules+1;			newOne._x = i*newOne._width+newOne._width;			newOne._y = 10+bottomBorder-(newOne._height)/2;			newOne._rotation = this["molecule"+t].rotation;			// init user-defined vars			newOne.direction = 0;	// angle of movement			newOne.magnitude = Number(this["molecule"+t].velocity);	// number of pixels to move per second			newOne.pocket1.ligandattached = 0;// start each molecule out with no ligands attached			newOne.pocket2.ligandattached = 0;// start each molecule out with no ligands attached			newOne.pocket3.ligandattached = 0;// start each molecule out with no ligands attached			newOne.mytype = this["molecule"+t].mytype;	// what the object am I: ligand or Molecule			newOne.myID =  this["molecule"+t].myID;	// what flavor			newOne.mybindingstrength =10;//Number(k.text.text)/Number(Kd.text.text);// bindstrength.text.text;	// how strongly ligands bind to me			newOne.myrotationdirection = myRandom(-1, 1);	// what the object am I: ligand or Molecule			// init internal vars			newOne.changestate = this["molecule"+t].changestate;			newOne.mybounce = this["molecule"+t].mybounce;	// convert angle to radians				newOne.watchEnvironment = this["molecule"+t].watchEnvironment;			newOne.direction = 0;	// convert angle to radians			// calculate how far to move horizontally and vertically per second			newOne.moveX = 0;			newOne.moveY = 0;			// record the time of this obj's birth			newOne.lastTime = getTimer();		}		offset = maxMolecules;							for (var i=0; i < this["molecule"+t].numMolecules; i++) {//top membrane			newname = "molecule"+Number(this["molecule"+t].numMolecules+i);			newlevel =  -Number(t*1000+i+ this["molecule"+t].numMolecules);			newOne = this["objectContainer"+t].attachMovie(this["molecule"+t].cast, newname, newlevel);			maxMolecules = maxMolecules+1;			newOne._x = i*newOne._width+newOne._width;			newOne._y =topBorder2+(newOne._height)/4*3;			newOne._rotation = 180-this["molecule"+t].rotation;			// init user-defined vars			newOne.direction = 0;	// angle of movement			newOne.magnitude = Number(this["molecule"+t].velocity);//myRandom(10, 250);	// number of pixels to move per second			newOne.pocket1.ligandattached = 0;// start each molecule out with no ligands attached			newOne.pocket2.ligandattached = 0;// start each molecule out with no ligands attached			newOne.pocket3.ligandattached = 0;// start each molecule out with no ligands attached			newOne.mytype =  this["molecule"+t].mytype;	// what the object am I: ligand or Molecule			newOne.myID = this["molecule"+t].myID;	// what flavor			newOne.mybindingstrength = 10;//Number(k.text.text)/Number(Kd.text.text);//Number(bindstrength.text.text);	// how strongly ligands bind to me			newOne.myrotationdirection = myRandom(-1, 1);	// what the object am I: ligand or Molecule			// init internal vars			newOne.changestate = this["molecule"+t].changestate;			newOne.direction = 0;	// convert angle to radians				newOne.mybounce = Boolean(this["molecule"+t].mybounce);				// calculate how far to move horizontally and vertically per second			newOne.moveX = 0;			newOne.moveY = 0;			// record the time of this obj's birth			newOne.lastTime = getTimer();		}//end top membrane	}//end of attaching free proteins	}  //end of looping through cast being created//send out dimensions of the ligand box.	this._parent.myBroadcaster.broadcastMessage("changeVal","vol0", (rightBorder2-leftBorder2) * (bottomBorder2-topBorder2));		this._parent.myBroadcaster.broadcastMessage("changeVal","vol1", (rightBorder-leftBorder) * (bottomBorder-topBorder) - (rightBorder2-leftBorder2) * (bottomBorder2-topBorder2));	//	// create borders	attachMovie("border", "topBorderClip", 10000);	topBorderClip._y = topBorder;	topBorderClip._x = leftBorder;	topBorderClip._width=Number(rightBorder)-Number(leftBorder);	attachMovie("border", "bottomBorderClip", 10001);	bottomBorderClip._y = bottomBorder;	bottomBorderClip._x = leftBorder;	bottomBorderClip._width=Number(rightBorder)-Number(leftBorder);		attachMovie("border", "rightBorderClip", 10002);	rightBorderClip._y = topBorder;	rightBorderClip._x = rightBorder;	rightBorderClip._width=Number(bottomBorder)-Number(topBorder);	rightBorderClip._rotation = 90;	attachMovie("border", "leftBorderClip", 10003);	leftBorderClip._y = topBorder;	leftBorderClip._x = leftBorder;	leftBorderClip._width=Number(bottomBorder)-Number(topBorder);	leftBorderClip._rotation = 90;			// create borders for inner walls	attachMovie("border", "topBorderClip2", 10010);	topBorderClip2._y = topBorder2;	topBorderClip2._x = leftBorder2;	topBorderClip2._width=Number(rightBorder2)-Number(leftBorder2);	attachMovie("border", "bottomBorderClip2", 10011);	bottomBorderClip2._y = bottomBorder2;	bottomBorderClip2._x = leftBorder2;	bottomBorderClip2._width=Number(rightBorder2)-Number(leftBorder2);	attachMovie("border", "rightBorderClip2", 10012);	rightBorderClip2._y = topBorder2;	rightBorderClip2._x = rightBorder2;	rightBorderClip2._width=Number(bottomBorder2)-Number(topBorder2);	rightBorderClip2._rotation = 90;	attachMovie("border", "leftBorderClip2", 10013);	leftBorderClip2._y = topBorder2;	leftBorderClip2._x = leftBorder2;	leftBorderClip2._width=Number(bottomBorder2)-Number(topBorder2);	leftBorderClip2._rotation = 90;}function Create1Molecule(moleculeID,newname,newlevel,X,Y,Xoffset,Yoffset,mybounce,myclock){	newOne = this["objectContainer"+moleculeID].attachMovie(this["molecule"+moleculeID].cast, newname, newlevel);	newOne.id.text = moleculeID+"."+newlevel;	this["molecule"+moleculeID].numMoleculesOnstage+=1;	//this["molecule"+moleculeID].numFree += 1;	//this["molecule"+moleculeID].numFolded = this["molecule"+moleculeID].numFolded+1;//Diana this is likely to be incorrect				if ( X>-1 ) 	{ //use specified parameters	    if (Xoffset==0) {		    newOne._x = X;		} else {			newOne._x = myRandom(Number(X-Xoffset), Number(X+Xoffset));		};	} else { //random with space        newOne._x = myRandom(Number(leftBorder2), Number(rightBorder2));	};                                                                         //done setting the x value		if (Y>-1) { //use specified parameters		if (Yoffset==0) {			newOne._y = Y;			} else {			newOne._y = myRandom(Number(Y-Yoffset),Number(Y+Yoffset));			}	} else { //random with space			newOne._y = myRandom(Number(topBorder2),Number(bottomBorder2));		}                                                                             //done setting the y	if ((newOne._x>=leftBorder2 and newOne._x<=rightBorder2) and (newOne._y>=topBorder2 and newOne._y<= bottomBorder2)) 	    { 	    this["molecule"+moleculeID].totals0 +=1;		this._parent.myBroadcaster.broadcastMessage("changeVal","con0_"+moleculeID, this["molecule"+moleculeID].totals0);	} else {		//now check for the special exceptions		if ( (this.envtype==1 and newOne._y>bottomBorder2) or (this.envtype==2 and newOne._x>rightBorder2)) {			this["molecule"+moleculeID].totals2 +=1;			this._parent.myBroadcaster.broadcastMessage("changeVal","con2_"+moleculeID, this["molecule"+moleculeID].totals2);		} else {		this["molecule"+moleculeID].totals1 +=1;		this._parent.myBroadcaster.broadcastMessage("changeVal","con1_"+moleculeID, this["molecule"+moleculeID].totals1)		}	}	//trace("ME="+newOne._x+"," +newOne._y+"  "+leftBorder2+"|"+rightBorder2+"|"+topBorder2+"|"+bottomBorder2+"     "+this["molecule"+moleculeID].totals0+"/"+this["molecule"+moleculeID].totals1+"/"+this["molecule"+moleculeID].totals2);	//trace("creating new ligand at location="+newOne._x+","+newOne._y);			newOne._rotation = myRandom(0, this["molecule"+moleculeID].rotation); //DIANA			newOne.direction = myRandom(this["molecule"+moleculeID].angle1,this["molecule"+moleculeID].angle2);	// angle of movement			newOne.magnitude = this["molecule"+moleculeID].velocity;// number of pixels to move per second			newOne.injectionforce = this["molecule"+moleculeID].injectionforce;// this will be added to movement to provide a decaying injection force			newOne.pocket1.ligandattached = 0;// start each molecule out with no ligands attached			newOne.pocket2.ligandattached = 0;// start each molecule out with no ligands attached			newOne.pocket3.ligandattached = 0;// start each molecule out with no ligands attached			//newOne.myMolecule = "";//don't initialize - leave undefined			newOne.mytype = this["molecule"+moleculeID].mytype;	// what  object am I: ligand or Molecule			newOne.myID = this["molecule"+moleculeID].myID;	// what flavor: 1,2,3			if ((mybounce == "false")  or (mybounce ==0)){				newOne.mybounce = 0 			} else {				newOne.mybounce = 1; 			};			//trace("newOne"+moleculeID+".mybounce>>>"+ newOne.mybounce);			newOne.newname.text = newname;			newOne.angle1 = this["molecule"+moleculeID].angle1;				newOne.angle2 = this["molecule"+moleculeID].angle2;				newOne.polarity = this["molecule"+moleculeID].polarity;				newOne.transporter = this["molecule"+moleculeID].transporter;				newOne.watchEnvironment = this["molecule"+moleculeID].watchEnvironment;			if (this["molecule"+moleculeID].brownian != undefined) {				newOne.brownian = this["molecule"+moleculeID].brownian;				} else {				newOne.brownian = 0;			}				newOne.myrotationdirection = myRandom(-1, 1);				// init internal vars			newOne.direction = radian(newOne.direction);	// convert angle to radians			//trace("direction of this new molecule="+newOne.direction);			// calculate how far to move horizontally and vertically per second			newOne.moveX = Math.cos(newOne.direction) * newOne.magnitude;			newOne.moveY = Math.sin(newOne.direction) * newOne.magnitude;//Here we need to check if we want to implemtent an equilibrium clock			/* for efficiency I want to create child arrays of the interactions*/							//FOR NOW WE WILL NOT DO BINDING AND EQUILIBRIUM AT THE SAME TIME			newOne.bindswith = new Array();			newOne.bindswith = this["molecule"+moleculeID].bindswith;			newOne.interactions = new Array();			newOne.interactions = this["molecule"+moleculeID].interactions;			newOne.seperateinto = new Array();			newOne.seperateinto = this["molecule"+moleculeID].seperateinto;						//			trace("                                                                                                                   newone.seperate="+newOne+"    "+newOne.seperateinto.productidm+"    "+ newOne.seperateinto.productidl);			newOne.changestate = this["molecule"+moleculeID].changestate;			newOne.returnsto = this["molecule"+moleculeID].returnsto;			newOne.isproduct = this["molecule"+moleculeID].isproduct;			if (myclock==undefined) {			    if (this["molecule"+moleculeID].k >0) {                   myclock = this["molecule"+moleculeID].k/this["molecule"+moleculeID].Kd;                } else {				    newOne.myclock = myRandom(-1,40);  			    }				//DIANA - this is a fudge.  We need to define the initial clock			} else {				newOne.myclock = myclock			}			newOne.myfreedomclock =-1;			/*interactions="changestate"if this is the case we will set the values in state1 and state2 for this moleculethe clock will be set randomly from these valueswhenever the clock runs out we will change state*/			if (newOne.changestate !=undefined) {				newOne.state1 =this["molecule"+moleculeID].state1;				//trace("newOne.state1="+newOne.state1);				newOne.state2 = this["molecule"+moleculeID].state2; //This is a pair of parameters: view?time				temp = newOne.state1.split(",");				newOne.myclock = myRandom(0,Number(temp[2]));				//trace("creating new molucule in state1 with clock="+newOne.myclock+ "  "+temp[2]);				newOne.currentState = temp[0];			}					newOne.lastTime = getTimer();                                                              // record the time of this obj's birth			//send message that this molecule has been created			this._parent.myBroadcaster.broadcastMessage("changeVal","M"+moleculeID, this["molecule"+moleculeID].numMoleculesOnstage);			//trace("created new molecule myclock="+newOne.myclock+"  and myMolecule="+newOne.myMolecule+"  and mytype = "+newOne.mytype);} // end of Create1Molecule						function addLigands(moleculeID,newAmount,X,Y,Xoffset,Yoffset,bounce,myclock) { //t lets us know which type of ligand//trace("addLigands myclock=  "+myclock);	//we add and remove ligands from the end	if (this["molecule"+moleculeID].maxMolecule != undefined)  {		limit = this["molecule"+moleculeID].maxMolecule;	} else {		limit=1	};		//trace("creating "+newAmount+" instances of "+moleculeID+"  limit="+limit);		// create and initialize the Ligand objects	for (var i= limit; i <  limit+newAmount; i++) {			newname = "molecule"+i;			newlevel = i;			this["molecule"+moleculeID].maxMolecule = this["molecule"+moleculeID].maxMolecule+1;   //bump the name counter - also used for level.			Create1Molecule(moleculeID,newname,newlevel,X,Y,Xoffset,Yoffset,bounce,myclock);  //-1 indicated totally random X,Y and delta						//X = Number(X+XOffset);			//Y = Number(Y+YOffset);	//_root.myBroadcaster.broadcastMessage("changeVal", "L", Number(Number(maxLigands)+Number(newAmount)));	}	CalculateFractionSaturated( this["molecule"+moleculeID].numMoleculesOnstage - this["molecule"+moleculeID].numBound,moleculeID) ;//GORDON}function removeLigands(moleculeID,theAmount) {	// remove Ligand objects from the bottom of the array		var thisClip = new Object();		if (theAmount>this["molecule"+moleculeID].numMoleculesOnstage) {			theAmount = this["molecule"+moleculeID].numMoleculesOnstage; // limit number to remove from what actually exists		}		thisKind = this["objectContainer" + moleculeID]; //pointer to the type of molecule - parent		for (var thisClip in this["objectContainer" + moleculeID]) { // loop through children - but keep count			//select object at the bottom of this object array			if (typeof(thisKind[thisClip])=="movieclip") {				ClipMolecule = thisKind[thisClip].myMolecule; //thisKind is one of the objectContainers and thisClip points to the correct child;				trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> remove "+ moleculeID);				//ClipMolecule now points to the attached Molecule - if there is one				if (ClipMolecule != undefined) { //go about detaching this molecule					//tell my molecule I am no longer attached					thisKind[thisClip].myPocket.ligandattached=0; //clear flag that this Molecule is bound				}; //end of if movieclip			if(theAmount>0) {				this["molecule"+moleculeID].numMoleculesOnstage -= 1; //reduce number on stage				removeMovieClip(thisKind[thisClip]);				theAmount -=1;			}		}; //end of if movieclip		} //this should be the end of the For	    trace ("clearing ligands="+this["molecule"+moleculeID].numMoleculesOnstage)		this._parent.myBroadcaster.broadcastMessage("changeVal","M"+moleculeID, this["molecule"+moleculeID].numMoleculesOnstage);//I need to send the new count			//CalculateFractionSaturated( this["molecule"+moleculeID].numMoleculesOnstage- this["molecule"+moleculeID].numBound,moleculeID) ;//GORDON}function removeMolecules(moleculeID,theAmount) {		//remove molecules		var thisClip = new Object();		if (theAmount>this["molecule"+moleculeID].numMoleculesOnstage) {			theAmount = this["molecule"+moleculeID].numMoleculesOnstage; // limit number to remove from what actually exists		}		thisKind = this["objectContainer" + moleculeID]; //pointer to the type of molecule - parent						for (var thisClip in this["objectContainer" + moleculeID]) { // loop through children of this molecule type - but keep count		//select object at the bottom of this object array			if (typeof(thisKind[thisClip])=="movieclip") {			trace(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> remove "+ moleculeID);					for (j=1; j<4; j++) { //loop through the 3 possible bindingsites on this molecule to release bound ligand					ClipLigand = thisKind[thisClip]["pocket"+j].myligand; //this points to one of the pockets of the molecule and releases it's ligand					//afterwards we will remove the molecule.					//ClipLigand now points to the attached ligand - if there is one					if (thisKind[thisClip]["pocket"+j].myligand != undefined) { //go about detaching this ligand						thisKind[thisClip].myPocket.ligandattached=0; //clear flag that this Molecule is bound					}					}					if (theAmount>0) {											this["molecule"+moleculeID].numMoleculesOnstage -= 1; //reduce number on stage						removeMovieClip(thisKind[thisClip]);						theAmount-=1;					} //end of if							} //		} //for this clip in		trace ("clearing molecules="+this["molecule"+moleculeID].numMoleculesOnstage)			this._parent.myBroadcaster.broadcastMessage("changeVal","M"+moleculeID, this["molecule"+moleculeID].numMoleculesOnstage);//I need to send the new count			//trace ("clearing ligand="+this["molecule"+moleculeID].numMoleculesOnstage+"/"+ this["molecule"+moleculeID].numBound)		CalculateFractionSaturated( this["molecule"+moleculeID].numMoleculesOnstage- this["molecule"+moleculeID].numBound,moleculeID) ;//GORDON}function removeThisLigand(theClip) {			// remove this specific Ligand from the array	thisKind = this["objectContainer" + theClip.myID]; //pointer to the type of molecule - prototype	ClipMolecule = theClip.myMolecule; //thisKind is one of the objectContainers and thisClip points to the correct child;//trace("                                                       >>>about to remove "+theClip);	//ClipMolecule now points to the attanched Molecule - if there is one	//trace("removeThisLigand="+theClip+"     "+thisKind+"   "+ClipMolecule);	if (ClipMolecule._name != undefined) { //go about detaching this molecule	//tell my molecule I am no longer attached		thisKind[thisClip].myPocket.ligandattached=0; //clear flag that this ligands Molecule is bound	}	this["molecule"+theClip.myID].numMoleculesOnstage-= 1; //reduce the free count for this ligand	this._parent.myBroadcaster.broadcastMessage("changeVal","M"+theClip.myID, this["molecule"+theClip.myID].numMoleculesOnstage);//I need to send the new count		removeMovieClip(theClip);	//CalculateFractionSaturated( this["molecule"+theClip.moleculeID].numMoleculesOnstage- this["molecule"+theClip.moleculeID].numBound,theClip.moleculeID) ;//GORDON}function removeThisMolecule(theClip) {			// remove this specific Molecule from the array	thisKind = this["objectContainer" + theClip.myID]; //pointer to the type of molecule - prototype	ClipMolecule = theClip.myligand; //thisKind is one of the objectContainers and thisClip points to the correct child;//trace("                                                       >>>about to remove "+theClip);	//ClipMolecule now points to the attanched Molecule - if there is one	if (ClipMolecule._name != undefined) { //go about detaching this molecule	//tell my ligand I am no longer attached		ClipMolecule.myMolecule=0; //clear flag in this Molecule's ligand is bound	}	this["molecule"+theClip.myID].numMoleculesOnstage-= 1; //reduce the free count for this ligand	this._parent.myBroadcaster.broadcastMessage("changeVal","M"+theClip.myID, this["molecule"+theClip.myID].numMoleculesOnstage);//I need to send the new count				removeMovieClip(theClip);	//CalculateFractionSaturated( this["molecule"+theClip.moleculeID].numMoleculesOnstage- this["molecule"+theClip.moleculeID].numBound,theClip.moleculeID) ;//GORDON}// ### moves a clip. called by each clip's internal enterFrame handlerfunction move (theClip) {	if (not (_global.movepause)) {	// check how much time has passed (we move a certain amount per second)	var thisTime = getTimer();	var elapsedTime = (thisTime - theClip.lastTime) / 1000;	theClip.lastTime = thisTime;	//trace("new molecule moves this way="+theClip.moveX+","+theClip.angle1+"    speed="+theClip.magnitude);		// calculate how far to move horizontally and vertically this tick	dobrownian = Math.random();	//if we need to add brownian motion	//trace("brownian="+dobrownian+"  "+theClip.brownian);	if(theClip.brownian >=dobrownian) {		//change my direction		//trace("begin change  ");		theClip.direction = myRandom(theClip.angle1,theClip.angle2);		theClip.moveX = Math.cos(theClip.direction) * theClip.magnitude;		theClip.moveY = Math.sin(theClip.direction) * theClip.magnitude;		newX = theClip.moveX * elapsedTime;		newY = theClip.moveY * elapsedTime;	} else {			newX = theClip.moveX * elapsedTime;		newY = theClip.moveY * elapsedTime;		}/*	if ((theClip.mytype=="ligand") and (theClip.myclock>0)) {		//if we are bound then follow molecule		//trace("BOUND ligand="+theClip._x+"   "+theClip.myMolecule._x+"+"+theClip.myPocket.bindingsite._x);		theClip._x =theClip.myMolecule._x+theClip.myPocket._x;		theClip._y = theClip.myMolecule._y+theClip.myPocket._y;		theClip.oldX=theClip._x;		theClip.oldY=theClip._y;	} else {		*/		theClip.oldX = theClip._x;		theClip.oldY = theClip._y;		theClip._x += newX;		theClip._y -= newY;	// note that we subtract vertically because							// flash coordinates are the reverse of cartesian	//}		TestWalls(theClip) ; 	CheckForInteraction(theClip) ;	//trace("envtype="+envtype+" counts["+ theClip.myID+"] 0="+this["molecule"+theClip.myID].totals0+" 1="+this["molecule"+theClip.myID].totals1+" 2="+this["molecule"+theClip.myID].totals2);}}// ### detects if theClip has gone out of bounds,//     and adjusts the clip's path as requiredfunction TestWalls (theClip) {	// store half the clip's height and width in convenient variables	var halfWidth = theClip._width / 2;	var halfHeight = theClip._height / 2;	// record the outer dimensions of the clip	var objLeftX = theClip._x - halfWidth;	var objRightX = theClip._x + halfWidth;	var objBottomY = theClip._y + halfHeight;	var objTopY = theClip._y - halfHeight;	var OLDobjLeftX = theClip.oldX - halfWidth;	var OLDobjRightX = theClip.oldX + halfWidth;	var OLDobjBottomY = theClip.oldY + halfHeight;	var OLDobjTopY = theClip.oldY - halfHeight;		// bounce check	gothrough = Math.random(); //random permiability of 0 to 1	if ((theClip._y<bottomBorder2) and (theClip._y>topBorder2)) { //only perform wall test if vertically within inner box		TestHorizontalCollisions(theClip,gothrough);//end of  testing 3										}  else {		// end testing horizonally but only with the correct vertical region		//now test outer walls		if (mybouce == false ) {			if (objLeftX < leftBorder) {				//trace("I am left of the left wall and not bouncing");			// check how much the clip went over the limit			var surplus = leftBorder + halfWidth - theClip._x;			// redirect the clip			theClip._x = rightBorder - halfWidth;			theClip.oldX = theClip._x;			} else if (objRightX > rightBorder) {			var surplus = theClip._x - (rightBorder - halfWidth);			theClip._x = leftBorder + halfWidth;			theClip.oldX = theClip._x;			}		} else {		theClip.breakapart = false;		if (objLeftX < leftBorder) {			var surplus = leftBorder + halfWidth - theClip._x;			// redirect the clip			theClip._x = leftBorder + halfWidth + surplus;			// reverse the clip's vertical direction			theClip.moveX *= -1;			theClip.breakapart = true;		} else if (objRightX > rightBorder) {			var surplus = theClip._x - (rightBorder - halfWidth);			theClip._x = rightBorder - halfWidth - surplus;			theClip.moveX *= -1;			theClip.breakapart = true;		}			} 			} 	//done testing for horizontal bounce or penetration			// check for vertical bounce	if ((theClip._x>=leftBorder2) and (theClip._x<=rightBorder2)) {//only perform wall test if horizontally within inner box			TestVerticalCollisions(theClip,gothrough)	} else {		if (objTopY < topBorder) {//check for just outer walls			var surplus = topBorder + halfHeight - theClip._y;			theClip._y = topBorder + halfHeight + surplus;			theClip.moveY *= -1;			theClip.breakapart = true;		} else if (objBottomY > bottomBorder) {//			var surplus = theClip._y - (bottomBorder - halfHeight);			theClip._y = bottomBorder - halfHeight - surplus;			theClip.moveY *= -1;			theClip.breakapart = true;		}	}//end testing for inner vertical bounce	}function TestHorizontalCollisions(theClip,gothrough) {	// store half the clip's height and width in convenient variables	var halfWidth = theClip._width / 2;	var halfHeight = theClip._height / 2;	// record the outer dimensions of the clip	var objLeftX = theClip._x - halfWidth;	var objRightX = theClip._x + halfWidth;	var objBottomY = theClip._y + halfHeight;	var objTopY = theClip._y - halfHeight;	var OLDobjLeftX = theClip.oldX - halfWidth;	var OLDobjRightX = theClip.oldX + halfWidth;	var OLDobjBottomY = theClip.oldY + halfHeight;	var OLDobjTopY = theClip.oldY - halfHeight;if ((OLDobjRightX <= leftBorder2)  and (leftBorder2< objRightX)) {//test 0 //trace("0=");			// reverse the clip's horizontal direction			if ( (gothrough<theClip.polarity[0])) {//changed this from gothrough<.9				//leave path alone		 		this["molecule"+theClip.myID].totals0+=1; //add one to center region		  		this["molecule"+theClip.myID].totals1-=1; //remove one from outer region				this._parent.myBroadcaster.broadcastMessage("changeVal","con0_"+theClip.myID, this["molecule"+theClip.myID].totals0);				this._parent.myBroadcaster.broadcastMessage("changeVal","con1_"+theClip.myID, this["molecule"+theClip.myID].totals1);			} else {	 // redirect the clip				var surplus = theClip._x-(leftBorder2 - halfWidth);							theClip._x = leftBorder2 - halfWidth - surplus;				theClip.moveX *= -1;			}			return;		} ;		if ((OLDobjRightX <= rightBorder2) and (rightBorder2 < objRightX)) {//test 2 		//trace("2=");			// reverse the clip's horizontal direction			if ( (gothrough<theClip.polarity[2]) ) {//changed this from gothrough<.9				//leave path alone				if (objRightX > rightBorder) {					var surplus = theClip._x - (rightBorder - halfWidth);					theClip._x = rightBorder - halfWidth - surplus;					theClip.moveX *= -1;					theClip.breakapart = true;				} else {					//change area counts		  			this["molecule"+theClip.myID].totals0-=1; //remove one from inner region					if (this.envtype==2) {						this["molecule"+theClip.myID].totals2+=1; //add one to outer region					} else {						this["molecule"+theClip.myID].totals1+=1; //add one to second outer region					}				}			} else {	 // redirect the clip				var surplus = theClip._x - (rightBorder2 -halfWidth) ;						theClip._x = rightBorder2 - halfWidth - surplus;				theClip.moveX *= -1;			}			return;		} ;		if ((OLDobjLeftX >= leftBorder2) and (leftBorder2 > objLeftX))  {//test 1		//trace("1=");			if ( (gothrough<theClip.polarity[1]) ) {				//leave path alone				if (objLeftX < leftBorder) { //make it bounce					// check how much the clip went over the limit					var surplus = leftBorder + halfWidth - theClip._x;					// redirect the clip					theClip._x = leftBorder + halfWidth + surplus;					// reverse the clip's vertical direction					theClip.moveX *= -1;					theClip.breakapart = true;				} else {						//just change area counts						this["molecule"+theClip.myID].totals0-=1; //remove one from center region		  				this["molecule"+theClip.myID].totals1+=1; //add one to outer region				}			} else {	// redirect the clip				var surplus = leftBorder2 +halfWidth - theClip._x;				//trace("theClip._x="+theClip._x+"  leftBorder2="+leftBorder2+"  halfwidth="+halfWidth+"  surplus="+ (leftBorder2 +halfWidth - theClip._x)+"  new clips._x="+(leftBorder2 + halfWidth + surplus));				theClip._x = leftBorder2 + halfWidth + surplus;				theClip.moveX *= -1;				theClip.breakapart = true;			}			return;			} //end of  testing 1				if ((OLDobjLeftX >= rightBorder2) and (rightBorder2 > objLeftX))  {//test 3			if ( (gothrough<theClip.polarity[3]) ) {				//leave path alone				this["molecule"+theClip.myID].totals0+=1; //add one to inner region				if (this.envtype==2) {					this["molecule"+theClip.myID].totals2-=1; //remove one from outer region				} else {					this["molecule"+theClip.myID].totals1-=1; //remove one from second outer region				}			} else {	// redirect the clip				var surplus =  rightBorder2 + halfWidth-theClip._x;				theClip._x = rightBorder2 + halfWidth + surplus;				theClip.moveX *= -1;				theClip.breakapart = true;			}			return;		} 		//check outer walls		IShouldBounce = theClip.mybounce;		if (IShouldBounce == 0) {			//trace("I need to wrap and I will return to"+theClip.myID+"    "+theClip.returnsto);			if (objLeftX < leftBorder) {			// check how much the clip went over the limit				var surplus = leftBorder + halfWidth - theClip._x;			// redirect the clip				theClip._x = rightBorder - halfWidth;				theClip.oldX = theClip._x;								if (String(theClip.returnsto)!="undefined") {					//trace("I need to wrap and I will return to"+theClip.returnsto);					//if (theClip.isproduct) {						addLigands(theClip.returnsto,1,theClip._x-20,theClip._y-20,-1,-1,theClip.mybounce);						removeThisLigand(theClip);					//}				}			} else if (objRightX > rightBorder) {				var surplus = theClip._x - (rightBorder - halfWidth);				theClip._x = leftBorder + halfWidth;				theClip.oldX = theClip._x;				if (String(theClip.returnsto)!="undefined") {					//trace("I need to wrap and I will return to"+theClip.returnsto);					//This needs a parameter - but for now we want to kill the product when it goes through the outer wall										//if (theClip.isproduct) {						addLigands(theClip.returnsto,1,theClip._x+20,theClip._y-20,-1,-1,theClip.mybounce);						removeThisLigand(theClip);					//}				}			}						} else {			//trace(">>>>>>>>>>>>>>>>>bouncing from outer walls");		if (objLeftX < leftBorder) {			// check how much the clip went over the limit			var surplus = leftBorder + halfWidth - theClip._x;			// redirect the clip			theClip._x = leftBorder + halfWidth + surplus;			// reverse the clip's vertical direction			theClip.moveX *= -1;			theClip.breakapart = true;		} else if (objRightX > rightBorder) {			var surplus = theClip._x - (rightBorder - halfWidth);			theClip._x = rightBorder - halfWidth - surplus;			theClip.moveX *= -1;			theClip.breakapart = true;		}		}		} //end testing for horizontal collisionsfunction TestVerticalCollisions(theClip,gothrough) {	// store half the clip's height and width in convenient variables	var halfWidth = theClip._width / 2;	var halfHeight = theClip._height / 2;	// record the outer dimensions of the clip	var objLeftX = theClip._x - halfWidth;	var objRightX = theClip._x + halfWidth;	var objBottomY = theClip._y + halfHeight;	var objTopY = theClip._y - halfHeight;	var OLDobjLeftX = theClip.oldX - halfWidth;	var OLDobjRightX = theClip.oldX + halfWidth;	var OLDobjBottomY = theClip.oldY + halfHeight;	var OLDobjTopY = theClip.oldY - halfHeight;//trace("are we watching environment?="+theClip.watchEnvironment);		if ((OLDobjBottomY < topBorder2) and ( objBottomY >= topBorder2)) {				//testing 4			if(theClip.myID==2 and theClip.watchEnvironment=="1") { //only active if we want to modify polarities because of system activity DIANA FUDGE			//trace("are we watching environment?="+theClip.watchEnvironment);				if ( (this["molecule"+1].totals1 / (this["molecule"+1].totals1+this["molecule"+1].totals0)  ) > ( this["molecule"+theClip.myID].totals1 / (this["molecule"+theClip.myID].totals1+this["molecule"+theClip.myID].totals0)) ) { 					myEnvironmentFactor =  Number(theClip.polarity[4]) - Number((1-theClip.polarity[4])/2); //make probability a little higher				} else {					myEnvironmentFactor =  Number(theClip.polarity[4]) + Number((1-theClip.polarity[4])/2); //make probability a little smaller				}			//trace("myEnvironmentFactor 4="+myEnvironmentFactor);			} else {				myEnvironmentFactor=theClip.polarity[4];			}			//trace("4="+myEnvironmentFactor+"     "+ (this["molecule"+1].totals1 / (this["molecule"+1].totals1+this["molecule"+1].totals0)  )+"    "+( this["molecule"+theClip.myID].totals1 / (this["molecule"+theClip.myID].totals1+this["molecule"+theClip.myID].totals0)));			if (gothrough< myEnvironmentFactor) {				//leave path alone//	trace(theClip+"  "+"                                                       went through for vector 4="+gothrough+"  "+theClip.polarity[4]);				this["molecule"+theClip.myID].totals0+=1; //add one to center region		  		this["molecule"+theClip.myID].totals1-=1; //remove one from outer region				this._parent.myBroadcaster.broadcastMessage("changeVal","con0_"+theClip.myID, this["molecule"+theClip.myID].totals0);				this._parent.myBroadcaster.broadcastMessage("changeVal","con1_"+theClip.myID, this["molecule"+theClip.myID].totals1);				//trace("4con0-"+theClip.myID+"="+this["molecule"+theClip.myID].totals0);			} else {					var surplus = theClip._y - (topBorder2 - halfHeight);				theClip._y = topBorder2 - halfHeight - surplus;				theClip.moveY *= -1;				theClip.breakapart = true;			}			//trace(theClip+"  "+"return");			return;		};		if ((OLDobjBottomY  <= bottomBorder2) and (objBottomY > bottomBorder2)) {		//testing 6		//trace("6=");			if ( (gothrough<theClip.polarity[6]) ) {				//leave path alone				if (objBottomY > bottomBorder) {					var surplus = theClip._y - (bottomBorder - halfHeight);					theClip._y = bottomBorder - halfHeight - surplus;					theClip.moveY *= -1;					theClip.breakapart = true;				} else {					this["molecule"+theClip.myID].totals0-=1; //remove one from inner region					if (this.envtype==1) {						this["molecule"+theClip.myID].totals2+=1; //add one to outer region					} else {						this["molecule"+theClip.myID].totals1+=1; //add one to second outer region					}					//trace("6con0-"+theClip.myID+"="+this["molecule"+theClip.myID].totals0);					this._parent.myBroadcaster.broadcastMessage("changeVal","con0_"+theClip.myID, this["molecule"+theClip.myID].totals0);					this._parent.myBroadcaster.broadcastMessage("changeVal","con1_"+theClip.myID, this["molecule"+theClip.myID].totals1);					this._parent.myBroadcaster.broadcastMessage("changeVal","con2_"+theClip.myID, this["molecule"+theClip.myID].totals2);				}			} else {					var surplus = theClip._y - (bottomBorder2 - halfHeight);				theClip._y = bottomBorder2 - halfHeight - surplus;				theClip.breakapart = true;				theClip.moveY *= -1;			}			return;		}// end testing 6		if ((OLDobjTopY >= topBorder2) and (topBorder2 > objTopY)) {						//testing 5					if(theClip.myID==2 and theClip.watchEnvironment=="1") {				if ( (this["molecule"+1].totals1 / (this["molecule"+1].totals1+this["molecule"+1].totals0)  ) > ( this["molecule"+theClip.myID].totals1 / (this["molecule"+theClip.myID].totals1+this["molecule"+theClip.myID].totals0)) ) { 					myEnvironmentFactor =  Number(theClip.polarity[5]) + Number((1-theClip.polarity[5])/2); //make probability a little higher				} else {					myEnvironmentFactor =  Number(theClip.polarity[5]) - Number((1-theClip.polarity[5])/2); //make probability a little smaller				}			//trace("myEnvironmentFactor 4="+myEnvironmentFactor);			} else {				myEnvironmentFactor= theClip.polarity[5] ;			}			//trace("5="+myEnvironmentFactor);			if (gothrough< myEnvironmentFactor) {				//leave path alone for inside wall				if (objTopY < topBorder) { // but now test for outer wall					var surplus = topBorder + halfHeight - theClip._y;					theClip._y = topBorder + halfHeight + surplus;					theClip.moveY *= -1;					theClip.breakapart = true;				} else {					this["molecule"+theClip.myID].totals0-=1; //remove one from center region		  			this["molecule"+theClip.myID].totals1+=1; //add one to outer region					this._parent.myBroadcaster.broadcastMessage("changeVal","con0_"+theClip.myID, this["molecule"+theClip.myID].totals0);					this._parent.myBroadcaster.broadcastMessage("changeVal","con1_"+theClip.myID, this["molecule"+theClip.myID].totals1);					//trace("5con0-"+theClip.myID+"="+this["molecule"+theClip.myID].totals0);				}			} else {					var surplus = topBorder2 + halfHeight - theClip._y;				theClip._y = topBorder2 + halfHeight + surplus;				theClip.moveY *= -1;				theClip.breakapart = true;				//if (theClip.myID==1) {					//trace("bouncing  newY="+theClip._y);				//}			}			return;			};		if ((OLDobjTopY >= bottomBorder2) and (bottomBorder2 > objTopY)) {				//testing 7				//trace("7=");			if ((gothrough<theClip.polarity[7]) ) {				//leave path alone				this["molecule"+theClip.myID].totals0+=1; //add one to inner region				if (this.envtype==1) {					this["molecule"+theClip.myID].totals2-=1; //remove one from outer region				} else {					this["molecule"+theClip.myID].totals1-=1; //remove one from second outer region				}				this._parent.myBroadcaster.broadcastMessage("changeVal","con0_"+theClip.myID, this["molecule"+theClip.myID].totals0);				this._parent.myBroadcaster.broadcastMessage("changeVal","con1_"+theClip.myID, this["molecule"+theClip.myID].totals1);				this._parent.myBroadcaster.broadcastMessage("changeVal","con2_"+theClip.myID, this["molecule"+theClip.myID].totals2);				//trace("7con0-"+theClip.myID+"="+this["molecule"+theClip.myID].totals0);			} else {					var surplus = bottomBorder2 + halfHeight - theClip._y ;				theClip._y = bottomBorder2 + halfHeight + surplus;				theClip.moveY *= -1;				theClip.breakapart = true;			}			return;		}//end 7			// check for vertical bounce outer box when never within inner box				IShouldBounce = theClip.mybounce;		if (IShouldBounce == 0) {			//trace("I need to wrap and I will return to"+theClip.myID+"    "+theClip.returnsto);			if (objTopY < topBorder) {			// check how much the clip went over the limit				var surplus = topBorder + halfWidth - theClip._y;			// redirect the clip				theClip._y = bottomBorder - halfWidth;				theClip.oldY = theClip._y;								if (String(theClip.returnsto)!="undefined") {					//trace("I need to wrap and I will return to"+theClip.returnsto);					addLigands(theClip.returnsto,1,theClip._x-20,theClip._y-20,-1,-1,theClip.mybounce);					//if (theClip.isproduct) {					removeThisLigand(theClip);					//}				}			} else if (objBottomY > bottomBorder) {				var surplus = theClip._y - (bottomBorder - halfWidth);				theClip._y = topBorder + halfWidth;				theClip.oldY = theClip._y;				if (String(theClip.returnsto)!="undefined") {					//trace("I need to wrap and I will return to"+theClip.returnsto);					addLigands(theClip.returnsto,1,theClip._x+20,theClip._y-20,-1,-1,theClip.mybounce);					//if (theClip.isproduct) {					removeThisLigand(theClip);					//}				}			}				} else				{			if (objTopY < topBorder) {//4				var surplus = topBorder + halfHeight - theClip._y;				theClip._y = topBorder + halfHeight + surplus;				theClip.moveY *= -1;				theClip.breakapart = true;				return;			} else if (objBottomY > bottomBorder) {//6				var surplus = theClip._y - (bottomBorder - halfHeight);				theClip._y = bottomBorder - halfHeight - surplus;				theClip.moveY *= -1;				theClip.breakapart = true;				return;			}		}		}////                         CheckForInteractionfunction CheckForInteraction(theClip) {	theClip.myclock = Number(theClip.myclock) -1;  //decrement time	theClip.myfreedomclock = Number(theClip.myfreedomclock) -1;  //decrement time	//Be very careful putting this back into action.  It seems to break binding.	CheckSeperateInto(theClip);ChangeState(theClip);if ( (theClip.myclock<1) and (theClip.myfreedomclock<1) and (theClip.myMolecule== undefined)) { //make sure this is a ligand and not attached and not Productif (theClip.bindswith.length !=undefined) {    //if theClip has no bindswith value we do not try to test for bindingfor (bind=0; bind<theClip.bindswith.length;bind++) { 	//trace("bind="+bind+"  theClip.bindswith.length="+theClip.bindswith.length);/*loop through possible interactions with this type of molecule//FOR NOW WE ARE ONLY DOING BINDSWITH SO I WON'T ADD THE TEST FOR ANYTHING ELSE			*/			t = theClip.bindswith[bind].t; //pick up molecule type I can bind with			p = theClip.bindswith[bind].p; //pick up which pocket			//mv = theClip.bindswith[bind].mv; //pick up the molecule view when bound			b = theClip.bindswith[bind].b; //pick up which pocket view (ligand)			l = theClip._parent._name.substr(15,2);			myKd = theClip.bindswith[bind].Kd;			myk = theClip.bindswith[bind].k;			myKcat = theClip.bindswith[bind].Kcat;			myproductidm = theClip.bindswith[bind].productidm; ////      DIANA I don't see how this is useful.			//myproductidl = theClip.bindswith[bind].productidl;			theLigandType = this["molecule"+l]; //reference to the ligand index (molecule8)			theMoleculeType = this["molecule"+t];			//trace ("t="+t+"p="+p+"b="+b+" myproductidm="+myproductidm+" Kd="+myKd);			newOne = this["objectContainer"+t]; //this is an object reference	/*	I NEED TO CHANGE THIS TO LOOP THROUGH THE CHILDREN OF THIS PARENT - NOT THROUGH THE ARRAY        ??????????????????????????????????????????????????????    TODO	I also need to use the counters in the prototype array    this["molecule"+moleculeID].numFree = this["molecule"+moleculeID].numFree+1;	*/	group = this["objectContainer"+t];	for (thisMolecule in  this["objectContainer"+t]) { //loop through all of the molecules I can bind with - check for hit		//DIANA we probably need to loop through the pockets here		targetMolecule = newOne[thisMolecule];  		var newPocket = targetMolecule["pocket"+p];			//trace("                                                                                                                                              checkhit="+theClip);	//trace("checkhit="+theClip+"/"+newPocket.bindingsite+"   targetMolecule="+targetMolecule+"......"+newOne+"......"+thisMolecule);			if (theClip.hitTest(newPocket.bindingsite)) { //if ligand hits this molecule's pocket			//trace("HIT ONE");				//here if they touch				if (newPocket.ligandattached==0) { //if no ligand attached												//before attaching we need to check for inhibitors and other constraints				effect="";				if (targetMolecule.interactions[0] != undefined ) {				master = targetMolecule.interactions[0]["mp"];				slave = targetMolecule.interactions[0]["sp"];				effect = targetMolecule.interactions[0]["effect"];				}				///trace("===============================MASTER/SLAVE/EFFECT "+targetMolecule[master].ligandattached+"="+targetMolecule[slave].ligandattached+"="+master+"/"+slave+"/"+effect);				bindOK = true;				//trace("0");				if (effect == "inhibit") {					bindOK = false;					if (("pocket"+p == master) and (targetMolecule[slave].ligandattached==0)) {						//trace("1");						bindOK = true;//continue to bind					}; 					if (("pocket"+p == slave) and (targetMolecule[master].ligandattached==0))					{					//trace("2");					bindOK=true					}				} 								if (effect == "cooperate") {					bindOK=false;					if (("pocket"+p == master) and (targetMolecule[slave].ligandattached==0)) 					{						bindOK = true;					};					if (("pocket"+p == slave) and (targetMolecule[master].ligandattached==1))					{ 					bindOK = true;					}				}								if (bindOK==true) {					//trace("binding when mster="+targetMolecule[master].ligandattached+"   and p="+p+"  and l="+l);					newPocket.ligandattached=1;  //attach this ligand					theClip.myMolecule = targetMolecule;//remember which molecule object bound to this as a reference					theClip.myPocket = newPocket;  					theClip.myclock =myk/myKd;//Number(k.text.text)/Number(Kd.text.text);// bindstrength.text.text;//objContainer["molecule" + j].mybindingstrength;  //stay bound for a random period of time					theClip.myfreedomclock = theClip.myclock;					targetMolecule.myligand = theClip;					theMoleculeType.numBound += 1;					theLigandType.numBound += 1;					theMoleculeType.numFree -= 1;					theLigandType.numFree -= 1;					//trace(">>>>>>>>>>>>>>>>>>>>bound     theClip._x="+theClip._x);//DIANA							this._parent.myBroadcaster.broadcastMessage("changeVal","ML"+t,  Number(theMoleculeType.numBound));					this._parent.myBroadcaster.broadcastMessage("changeVal","M"+l, theLigandType.numFree);					this._parent.myBroadcaster.broadcastMessage("changeVal","M"+t, theMoleculeType.numFree);										newPocket.gotoAndPlay(b);//change pocket of this binding Molecule to bound view					//targetMolecule.gotoAndStop(mv); // only the pocket gets a specific bound look					//Diana removed changing molecule view 12/04/08					//trace("about to add "+ myproductidm +  " and remove "+theClip+"  +  "+targetMolecule+"  clock="+theClip.myclock);//	Here we will actually bind by killing the two and creating the new molecule at the location of the molecule//DIANADIANA                       addLigands(myproductidm,1,targetMolecule._x,targetMolecule._y,0,0,targetMolecule.mybounce,theClip.myclock);						removeThisLigand(theClip); 						removeThisMolecule(targetMolecule);																							//theClip._visible=false; //make the ligand invisible					//theClip.gotoAndStop("bound"); //change ligand to bound view					//setpause(10);					//DIANA OFF voice.start()					break;  //stop checking				} //bound				}// if no ligand attached			}  //if ligand hits pocket					}  //end loop on molecules} //loop through potential interaction types}}  //if ligand//CheckForRelease(theClip);//CheckForProduct(theClip);}  //end function// ### degree to radian converterfunction radian(degree) {	return (Math.PI/180) * degree;}// ### random integer generatorfunction myRandom (min, max) {	r = Math.random();	// toss away 1 if we get it	while (r == 1) {		r = Math.random();	}	return min + Math.floor(r * (max + 1 - min));}/*function CheckSeperateInto(theClip) {bind=0;	if ((theClip.seperateinto !=undefined) and (theClip.myclock<1)) {	//trace("             >>>>breakapart "+theClip+"   ="+theClip.seperateinto.productidl+"   ="+theClip.seperateinto.productidm);		if (theClip.seperateinto.productidl != undefined ) 		    {				theclock = theClip.seperateinto.k/theClip.seperateinto.Kd;				makeproduct = Math.random(); //*100;							if (theClip.mymolecule.bindswith[bind].Kcat >= makeproduct) { //if users probability is >= than random  make product										trace("making product with "+theClip+"  "+theClip.mymolecule.bindswith[0]+"  "+theClip.mymolecule.bindswith[bind].productidl);						  addLigands(theClip.mymolecule.bindswith[bind].productidl,1,theClip._x,theClip._y,-1,-1,theClip.mybounce,theclock);				} else {					trace("restoring ligand "+theClip.seperateinto.productidl);					addLigands(theClip.seperateinto.productidl,1,theClip._x,theClip._y,-1,-1,theClip.mybounce,theclock);				}				addLigands(theClip.seperateinto.productidm,1,theClip._x,theClip._y,-1,-1,theClip.mybounce,theclock);									removeThisLigand(theClip);				//don't do anything more with this clip			} //end if on check for productl			} ;  //end if seperateinto and clock runs out}*/function CheckSeperateInto(theClip) {	if ((theClip.seperateinto !=undefined) and (theClip.myclock<1)) {	//trace("             >>>>breakapart "+theClip+"   ="+theClip.seperateinto.productidl+"   ="+theClip.seperateinto.productidm);		if (theClip.seperateinto.productidl != undefined ) 		    {								makeproduct = Math.random(); //*100;				if (theClip.seperateinto.Kcat >= makeproduct) {					addLigands(theClip.seperateinto.productidp,1,theClip._x,theClip._y,0,0,theClip.mybounce);					//make product				} else {					//back to ligand					addLigands(theClip.seperateinto.productidl,1,theClip._x,theClip._y,0,0,theClip.mybounce);				}								addLigands(theClip.seperateinto.productidm,1,theClip._x,theClip._y,0,0,theClip.mybounce);									removeThisLigand(theClip);				//don't do anything more with this clip			} //end if on check for productl			} ;  //end if seperateinto and clock runs out}function ChangeState(theClip) {		/*We are going to implement phase/ state change here by allowing author to specifytheClip.changestate and two different state views.Temporarily this will only be tied to _global.f_f for fraction foldedstate1="folded?20" state2="unfolded?20"*/if ((theClip.changestate != undefined) and (theClip.myclock<1)) {			// check to see if it is time to change state and then reset clock			temp1 = theClip.state1.split(",");			temp2 = theClip.state2.split(",");			gochange = Math.random(); //random statechange of 0 to 1 //this is if we use simple random numbers			a = Number(this["molecule"+temp1[0]].numMoleculesOnstage);			b = Number(this["molecule"+temp2[0]].numMoleculesOnstage);			actual = (a / (a+b));			this._parent.myBroadcaster.broadcastMessage("changeVal","actual", actual); //temporarily brooadcast the fraction of molecutes in state1			if (gochange  <= _root.state1) {     //make sure this becomes a 1 - else go to a 2				if (theClip.myID==temp1[0]) {											// stay in state 1					//trace("                                                                                     <1stay as "+temp1[0]);					theClip.myclock = temp1[2];				} else {					//trace("                                                                                    <1change to "+temp2[0]);					theClip.currentState = temp1[0];  					theNewClip = addLigands(theClip.currentState,1,theClip._x,theClip._y,0,0,theClip.mybounce);					removeThisLigand(theClip);  //DIANA check to see if we could have a molecule at this point					theClip = theNewClip;					theClip.myclock = temp1[2];				}			}  else {				if (theClip.myID==temp2[0]) {											// change to a 1					theClip.myclock = temp2[2];				} else {					//trace(">2change to "+temp2[0]);					theClip.currentState = temp2[0];  					theNewClip = addLigands(theClip.currentState,1,theClip._x,theClip._y,0,0,theClip.mybounce);					removeThisLigand(theClip);  //DIANA check to see if we could have a molecule at this point					theClip = theNewClip;					theClip.myclock = temp2[2];				}										}//end text against gochange						} //end test changestate}function CheckForRelease(theClip) {	//test to see if we need to release from molecule		//if  (theClip.mytype == "ligand")  {       //begin testing to see if ligand should release from molecule - Diana 11/08		//check to see if it's time to release from pocket we should probably change this to not care if the behavior is that of a ligand.  just check the clocks for time running out.bind=0;/*if (theClip.myMolecule.myID!==theClip.bindswith[0].t) { 	bind=1;}*/if ((theClip.myPocket.ligandattached==1) and (theClip.myclock<1)) {  //see if time to free the ligand			//setpause(10);//YES so proceed			theClip.myclock=0;  //reset clock to 0				theClip.myfreedomclock = 20; //DIANA give me some time to get away from molecule									if (theClip.myMolecule.interactions[0]["effect"] == "cooperate")  {				temp = String(theClip.myPocket).split("."); //get my pocket				//trace("SLAVE="+theClip.myMolecule.interactions[0]["sp"] +">>>"+mv);				if (temp[4]==theClip.myMolecule.interactions[0]["sp"]) {					theClip.myMolecule.gotoAndStop(mv);// reset view all free				} else {					theClip.myMolecule.gotoAndStop("free");// reset view to one still bound				}			} else {				//trace("reset to free view");				theClip.myMolecule.gotoAndStop("free");// reset view all free							}							//trace(">>>>>>>>>>>check for release  "+theClip.myMolecule+"   "+theClip.myPocket+"             free"); //DIANA			theClip.gotoAndPlay("free"); //reset view			theClip.myPocket.gotoAndPlay("free"); 							//DIANA - we are now remembering which pocket is bound and is being freed at this point			theClip.myPocket.ligandattached=0;  //reset  bound flag//                                                               using bindswith of 0 temporarily.  I need to figure out which binding site.  Diana				l=theClip.myID;  //pick up the id of the ligand			t=theClip.myMolecule.myID;  //pick up the ID of the Molecule			theLigandType = this["molecule"+l]; //reference to the ligand index (molecule8)			theMoleculeType = this["molecule"+t];			//trace("...........................about to release starting with theMoleculeType  numBound=" +theMoleculeType  +  "   "+theMoleculeType.numBound);			theMoleculeType.numBound -= 1;			theLigandType.numBound -= 1;			theMoleculeType.numFree += 1;			theLigandType.numFree += 1;						if (theClip.myMolecule.transporter==1) {						if (Math.abs(theClip.myMolecule._y-theClip._y)>50) {					theClip._x = theClip.myMolecule._x-10; //spin away					theClip._y = theClip.myMolecule._y-10; //spin away					//trace("out the TOP");				} else {					//trace("out the BOTTOM");					theClip._x = theClip.myMolecule._x+theClip.myMolecule._width+10; //spin away					theClip._y = theClip.myMolecule._y+theClip.myMolecule._height+10; //spin away				}				theClip._visible=true; //make the ligand invisible				} else {				theClip._visible=true; //make the ligand invisible				}	}}	function setvalue(param,thevalue) {				this[param].text = thevalue;}function CalculateFractionSaturated(Lfree,myID) {	/*	this routine will calculate the fraction saturated whenever there is a change in the Ligands	Lfree is the number of unbound molecules in system	Y = [L]free / Kd + [L]free		[ML] = Y[M]total		Y = [ML] / ([M] + [ML]) = [ML]/[M]total		Lin = [L]free + [ML] = [L]free + [M]total * ( [L]free / Kd + [L]free )		These amounts are concentrations.  So it will work best if the ligand box 	has the same area inside the inner box as outside.		Something will add or remove ligand from the system  (Lfree) or change the number of molecules and we will 	calculate the new Lin ans send a message reporting that value		first Lfree must be calculated by the system and sent to this routine. 		Y = Lfree / ...		[Lin] = [L]free + [M]tot*[L]free/Kd+[L]free	*/	myInteractions = this["molecule"+myID].bindswith.split("&");	thisinteraction = myInteractions[0].split(","); 	 //the various parameters of this interaction seperated by ","	MyParts = thisinteraction[0].split(".");	t = MyParts[0].substr(8,2); //pick up molecule type	temp = thisinteraction[1].split("?");	myKd =Number(temp[1]); //these need to be parsed	temp = thisinteraction[2].split("?");	myk = Number(temp[1]);	//trace("currently using Kd="+myKd+"  and k="+myk);	Mtot = this["molecule"+t].numMoleculesOnstage;	myerror =  Math.random()*.05*myRandom(-1,1);	//trace("error = "+myerror );	Lin = (Lfree) + (Mtot * (Lfree)/(myKd + (Lfree))); //*myerror;		//trace("Mtot="+Mtot+"  Lfree="+Lfree+"  myKd="+myKd);	this._parent.myBroadcaster.broadcastMessage("changeVal","M"+myID+"*", Lin)	}function setpause(shorttime) {	//_global.movepause=true;	//_root.resetTheTimer(); //make sure the worlds clock is running	//_global.timer=_shorttime;					}